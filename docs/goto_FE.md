## State of Storybook 7 • Gert Hengeveld • GOTO 2023

URL: [https://www.youtube.com/watch?v=j6i0_CjhXxs](https://www.youtube.com/watch?v=j6i0_CjhXxs)

 1. Storybook is a popular frontend development tool for UI workflows, helping with component isolation and testing.
2. Version 7.0 focuses on workflow improvements and bug fixes.
3. Compatible with major frameworks like React, Angular, Vue, and Lit.
4. Helps developers work faster and with confidence by rendering components in isolation.
5. Storybook 7.0 introduces CSF3 (Component Story Format) for portable syntax across frameworks.
6. Testing features include interaction tests, visual debugging, assertions, time travel debugging, and a test runner for CI integration.
7. Documentation is done using MDX and Doc blocks with AutoDoc for generating documentation from existing stories.
8. Figma integrations offer add-on designs package, plugin for live view, and better design collaboration.
9. Improved support for frameworks like NextJS, Svelte, and SolidJS.
10. Ecosystem CI ensures daily testing of storybook variations and automation for easier upgrades.
11. Use MPX Storybook to initialize new projects or upgrade existing ones.


## Programming the Web with HyperLANG & HyperCLI • Mike Amundsen • GOTO 2023

URL: [https://www.youtube.com/watch?v=vcjOzcxIBdY](https://www.youtube.com/watch?v=vcjOzcxIBdY)

 - Hyper CLI is a tool inspired by 40-year-old technology, hypercard, allowing users to program one machine.
- It's a repurposed curl with memory, more advanced and capable of handling formats like HTML, JSON, and forms.
- The DSL for programming the web is called hyper Lang, which can inspect and manipulate responses from websites.
- Hyper Lang is a low code/no code tool that simplifies programming without sacrificing functionality.
- It uses a natural and understandable DSL inspired by Flomatic and Cobalt.
- The tool can run tests on APIs with configuration files for different environments.
- Using HTTP as an interface enables interaction with various services, promoting easy changes and adaptability.
- Hyper Lang supports multiple industries' APIs through HTTP interactions.
- Roy Fielding's work focuses on creating a stable internet system that adapts to change.
- Demonstrates using HTTP for CRUD operations in services, handling different formats like SOAP through extensions or plugins.
- A tool handles various authentication methods like SOAP, OAuth, and basic auth with a simple scripting language called Hyper Ling.
- Plugins are automatically loaded during startup, making them convenient but potentially dangerous due to the use of eval statement.
- Future improvements include hardening code, modularization, better error handling, and more plugin support.
- Potential for domain-specific languages (DSLs) and integration with other programming languages.
- Focus on HTTP, event-driven challenges, security enhancements, more plugins, and OS integration.


## Design for Developers • Stephanie Stimac & Sophie Freiermuth • GOTO 2023

URL: [https://www.youtube.com/watch?v=6bDqpshjSpI](https://www.youtube.com/watch?v=6bDqpshjSpI)

 1. Stephanie Stimac's book, "Design for Developers," teaches developers the basics of design to improve communication and collaboration with designers.
2. The goal is to help developers identify issues in user interfaces and fix them efficiently without wasting resources or time.
3. Design smartness is emphasized, where developers learn about design concepts but don't become experts, allowing for better teamwork with designers.
4. The book covers topics like typography, color theory, layouts, and user experience to help developers build polished designs.
5. It also highlights the importance of designers learning about development and vice versa.
6. The approach is flexible depending on the context of work.
7. The book covers design fundamentals, research, UX design, web layout, typography, color theory, testing, and iteration.
8. Color theory is an interesting aspect of design, considering psychology, cultural connotations, and accessibility concerns.
9. Browser extensions or developer tools can help identify colorblindness issues.
10. Understanding individual and collective perceptions plays a role in design preferences.
11. Valid reasons should be behind feedback rather than personal preferences.
12. Design should cater to the target audience, not just stakeholders' opinions.
13. The book discusses the importance of understanding color theory and its application in designing effective experiences.
14. Collaboration between different roles in product development is crucial for better products and more effective teamwork.
15. Stephanie Stimac offers design services, talks on dual-screen design, PWAs, and consults as a designer, product manager, and developer advocate.
16. Her website has contact information for reaching out.


## Simplifying Dev Environments with the Right Tools • Christian Heilmann & Julian Wood • GOTO 2022

URL: [https://www.youtube.com/watch?v=o0bYu0HVjNU](https://www.youtube.com/watch?v=o0bYu0HVjNU)

 1. Chris Heilmann discusses his work on developer tools in Microsoft's Edge browser, focusing on improving efficiency and accessibility for all developers.
2. VS Code is an example of a lightweight, interchangeable tool that can be used across different environments. Developers should use web technologies for their tools to make them more flexible and mixable.
3. Breaking down the monolithic idea of IDEs and debugging tools will lead to better developer experiences. Lightweight IDEs and tools are desired, with VS Code as an example.
4. Improving UX/UI for developers is crucial. Interfaces should learn from user behavior and contextual tooling is essential for efficiency. Simplifying interfaces and reducing feature creep is important.
5. Exposing different services within IDEs can be beneficial. Discussions on improving developer tools and interfaces include machine learning-aided autocompletion in coding, such as GitHub Copilot and Amazon CodeWhisperer.
6. The importance of contextual tooling for developers is highlighted, along with the potential for machine learning to learn from a user's development style and improve code quality.
7. The role of code generation as an assistant rather than writing the code itself is mentioned. The possibility of evolving team standards through consistent usage of these systems is also discussed.
8. CodeWhisperer from Amazon uses comments to generate code samples based on the user's intent, while GitHub Copilot explains code in natural language. Live analysis in IDEs provides real-time feedback on code quality.
9. The focus should be on improving development tools and making them more accessible for everyone. Suggestions include integrating design tools like Figma into web development to reduce redundancy, considering various user needs (accessibility, low bandwidth situations), and learning through teaching others and sharing knowledge.


## Developer Tools That Shouldn't Be Secrets • Christian Heilmann • GOTO 2022

URL: [https://www.youtube.com/watch?v=lz-nUdotdx4](https://www.youtube.com/watch?v=lz-nUdotdx4)

 1. Developer tools are available in all major browsers, offering various features for web development.
2. Focus mode allows users to view one tool at a time, making navigation easier.
3. Command menu (Ctrl+Shift+P) is powerful for accessing features without navigating through menus.
4. Themes can be changed using command lines, customizing the developer tools' appearance.
5. Console log is popular for debugging purposes and styling output.
6. Developer tools are built with web technologies, allowing inspection of their source code.
7. Use console log for debugging and styling output.
8. Dollar sign ($) is a shortcut for query selector in the document.
9. Put curly braces around variables to differentiate them from strings.
10. Use different logging levels (info, warning, error) to filter console messages.
11. Console table displays information about elements in an organized manner.
12. Console count shows how many times a function was called.
13. Copy command: Copy any console output without highlighting, useful for sharing snippets.
14. Monitor events: Observe specific events on elements without adding event handlers.
15. Live expressions (ISR): Display JavaScript expressions in the console without affecting other code.
16. Device mode: Test responsive design, emulate different devices, and simulate slow connections.
17. Media queries: View them in device mode to test designs on various screen sizes.
18. Rulers: Measure pixel distances for pixel-perfect designs.
19. Throttling: Simulate slow connections or low-end devices to check app performance.
20. Developer tools offer accessibility features like locking info bars and inspecting web page elements.
21. Breakpoints can be set in the debugger to monitor changes in website content.
22. A note screenshot feature allows users to take a screenshot of paused video elements, potentially bypassing copyright restrictions.
23. Developer tools are useful for exploring and manipulating websites in various ways.
24. Elements tool lets you take screenshots of streaming media content, but it's not recommended.
25. Sources tool provides access to all website documents and allows editing them locally.
26. Lock points enable console logging in third-party JavaScript without accessing source code.
27. Overrides let you load local files instead of server ones for testing purposes.
28. Snippets are useful for saving frequently used code snippets, automating tasks, and sharing scripts among developers.
29. Developer tools offer various features such as Flexbox visualization, color adjustments, and a changes tool for tracking file edits.
30. Local servers can be used to edit files in Visual Studio Code.
31. DevTools for Visual Studio Code helps developers make local changes that reflect in their source code.
32. SAS integration follows Source maps for changes.
33. Live analysis highlights errors and offers quick fixes.
34. Inspecting developer tools is possible through a command.
35. Contributions can be made by joining GitHub repositories.
36. Dear console tool extracts image names from webpages.
37. Developer tools are available in most browsers, allowing exploration of the web.


## Deno: The JavaScript Runtime for the Serverless Era • Ryan Dahl • GOTO 2022

URL: [https://www.youtube.com/watch?v=VDKJ1rSj-NI](https://www.youtube.com/watch?v=VDKJ1rSj-NI)

 - Dream software stack: JavaScript, serverless, global infrastructure
- Dino: JavaScript framework for professional developers with TypeScript integration, standard library, third-party modules, browser compatibility, and self-contained binaries
- Demo: Pulling in Express npm module and creating a simple app using Dino
- Dino Deploy: Builds serverless systems using Dino, hosting functions in 34 data centers worldwide
- Goal of Dino framework: Improve development experience for JavaScript developers with better security and performance
- Dino Land example: Handling dynamic responses
- Post Unix future: Serverless edge runtimes like Cloudflare Workers and Dino Deploy
- Fresh web framework: Fast, efficient, and smaller in size compared to Create React App (84KB vs 339MB)
- Comparison between Fresh and Create React App: Optimization needed in server-side JavaScript and infrastructure
- Speaker's work: Improving Dino framework and hiring


## The Psychology of UX • Fabio Pereira • GOTO 2022

URL: [https://www.youtube.com/watch?v=rf9Gh-VMvIk](https://www.youtube.com/watch?v=rf9Gh-VMvIk)

 1. Understanding human behavior is crucial for interacting with others, making better decisions, and avoiding manipulation.
2. Psychology helps in understanding how our choices are influenced by technology, fast thinking (System 1) and slow thinking (System 2).
3. Behavioral economics focuses on people's decision-making processes and psychology to influence them.
4. Optical illusions show the impact of biases on perception, while concepts like decoy effect and defaults affect choices in various contexts.
5. Amazon Go store and anticipatory shipping are examples of seamless experiences that can influence behavior.
6. Framing and middle option bias affect decision-making in presentations and marketing.
7. The Ikea effect refers to people valuing their own creations more than professionally made ones, while status quo bias prefers the current situation.
8. Digital nudge concept aims to positively influence decisions in a digital environment.
9. Understanding what people want and need is crucial before designing for them, considering ethics and morals.
10. Dataism relies on companies and organizations with our data to make decisions, while new technologies like continuous glucose monitors and stress monitoring watches can improve health and wellbeing.
11. Humane Tech aims to enhance the digital world by designing systems that focus on improving lives rather than hijacking attention.
12. The Social Dilemma highlights the issue of social media platforms keeping users engaged for longer periods, emphasizing the need for better technology that enhances experiences and allows people to focus on their real lives.


## Design for the Utopia You Want, Not the Dystopia You're In • Chris Atherton • GOTO 2022

URL: [https://www.youtube.com/watch?v=Q77GT8srcsQ](https://www.youtube.com/watch?v=Q77GT8srcsQ)

 - Interest in understanding human needs and wants.
- Dystopian future, techwear evolution, COVID-19 pandemic, climate crisis. Criticism of Bitcoin mining's carbon footprint. Ryan Broderick defines dystopia as technology robbing people of personal agency. Dan Horn discusses Facebook's shadow profiles for non-users and privacy concerns.
- Dystopia becoming meaningless due to overuse; technology can rob users of personal agency by forcing them to give up information without choice.
- Social media and mainstream media noise, attention weaponization, psychology lessons from old white guys (William James, Martin Seligman, B.F. Skinner, Abraham Maslow, Carl Rogers). Technology designers should consider human psychology when creating products.
- William James on attention span; Martin Seligman's learned helplessness; technology and loss of agency.
- Convenience in tech doesn't equate to consent for others; coping with helplessness through humor and satire.
- Placebo agency, behaviorist psychology concepts (intermittent variable reward, spaced retrieval), efficient use of time.
- GDPR challenges, Twitter as an outrage machine, advertising repetition (mere exposure effect).
- Design decisions impact users' experience; empowerment strategies: ad blockers, distracting clothing, privacy-focused tech.
- Importance of design systems for fast response to crises and policy changes.
- Voting for representatives who support privacy and user-centered design. Diverse teams lead to diverse product output. Avoid arguments and focus on direct action. Follow Greta Thunberg's philosophy: act for the Utopia you want.


## White-Hat Attention Jacking for Accessibility, Fun & Profit • Chris Atherton • GOTO 2022

URL: [https://www.youtube.com/watch?v=VwocXCyOieM](https://www.youtube.com/watch?v=VwocXCyOieM)

 1. Attention is a limited resource that needs to be managed effectively.
2. Working memory (short-term memory) can hold around 4-7 items, depending on factors like familiarity and chunking.
3. Cognitive load theory focuses on how we distribute working memory; complex information requires more resources.
4. Reducing cognitive load is essential for users to efficiently complete tasks.
5. Attention is crucial for cognitive capacity, affected by internal and external factors.
6. New information can steal attention, making it hard to return to previous tasks.
7. Movement attracts attention; consistent animations are more engaging than sudden changes.
8. Accessibility should include options for turning off animations.
9. Multitasking requires a lot of working memory management.
10. Websites should consider how they handle user attention and information flow.
11. Attention is crucial in web design and user experience.
12. Inattentional blindness can occur when attention is divided between multiple tasks or elements on a page.
13. Design systems help with weight and visual hierarchy, making it easier for users to focus on important information.
14. Content design and reading direction play a role in guiding attention.
15. Compressing resolution can highlight the most visually striking areas of an image.
16. Primary buttons should be distinct from secondary and tertiary ones for accessibility purposes.
17. Attention management is crucial in web design.
18. Design systems help with weight and visual hierarchy.
19. Images can be distracting, especially for screen readers.
20. Prioritize content and avoid auto-playing media.
21. Blind people may have slightly better working memory.
22. Website "how I experience webtoday.com" demonstrates attention issues in web design.


## How the SJGAR Stack Accelerated Our Digital Transformation • Erik Ammerlaan • GOTO 2022

URL: [https://www.youtube.com/watch?v=V5zW3ig2lG8](https://www.youtube.com/watch?v=V5zW3ig2lG8)

 - National Nederlanden (NN) is a large financial institution with over $30 billion in worth, aiming to transform into a tech company.
- The Sugar Stack was created by Eric Ammerlaan's team for business transformation, using serverless architecture, JavaScript, React, and cloud native services.
- Serverless reduces operations workload, allowing engineers to focus on customer value.
- React is used for both frontend and backend development, making it easy to switch between web and mobile apps.
- Cloud native services provide built-in security controls, enabling teams to focus on innovation without compromising quality or security.
- Benefits of serverless technologies include reduced operations work, security control baked in, and a focus on customer value.
- Embrace cloud native services like AWS Lambda, S3, etc., use React for frontend and backends with similar patterns and libraries, and leverage the Apollo library to speed up development.
- NN's Culture Starter initiative helps functional teams adopt an engineering mindset.
- The company aims to make platform teams more attractive to engineers by promoting their learnings through successful solutions.
- Introduce design sprints for team bonding and learning new technologies, reducing duplication of technology stacks and focusing on smarter operations.
- Encourage continuous delivery and small incremental releases to production.


## Did We(b Development) Lose the Right Direction? • Stefan Judis • GOTO 2021

URL: [https://www.youtube.com/watch?v=3PmPkZJ22Cc](https://www.youtube.com/watch?v=3PmPkZJ22Cc)

 - Over the past decade, web development has seen rapid advancements in frontend technologies with frameworks like Angular and React emerging within a few years.
- Performance optimization is crucial using tools such as Lighthouse and WebPageTest.org.
- Stefan's personal blog was outperformed by another website built with minimal knowledge about web development, highlighting the ease of making mistakes in this field.
- Key takeaways include avoiding complex applications and focusing on user experience through simple websites with minimal dependencies.
- Static site generators like 11ty can help create pure websites with high Lighthouse scores, prioritizing performance and user benefits.
- Universal JavaScript apps may not be necessary for content sites as they add complexity and potentially slow down page load times. Progressive enhancement is an alternative approach to ensure basic functionality regardless of JavaScript availability.
- React's HTML-only version has a similar user experience with less data usage compared to its JavaScript counterpart, showcasing the importance of optimizing for slower connections and limited data plans.
- Excessive JavaScript usage can harm user experience; Gmail is an example of a site with high JavaScript usage but still enjoyable.
- Client-side navigation breaks accessibility for assistive technology; new proposals like document transition aim to improve the situation.
- Astro and Svelte are frameworks that focus on reducing JavaScript usage, while React, Vue, and Next.js have made efforts to reduce JavaScript size.
- A great site should just work, focusing on HTML, CSS, and JavaScript foundations; front-end developers should concentrate on core skills rather than complex tools and processes.


## What Are Micro-Frontends & How to Use Them • Luca Mezzalira & Lucas Dohmen • GOTO 2022

URL: [https://www.youtube.com/watch?v=-thWgobMW_I](https://www.youtube.com/watch?v=-thWgobMW_I)

 1. Micro-frontends, a topic explored by Luca Mezzalira for seven years, focuses on independent deployments and modularity.
2. The motivation behind micro-frontends is to achieve flexibility similar to microservices in frontend development.
3. Independent deployments are crucial for distributed systems like micro-frontends and microservices.
4. Startups may benefit more from monolithic architectures due to their focus on validating assumptions and reaching prime time.
5. Modularity can be achieved at different levels, including code, infrastructure, architecture, and organization.
6. Deciding between monolithic or microservices architecture depends on context and priorities.
7. Micro-frontends can be split horizontally (multiple teams working together) or vertically (one team responsible for a view).
8. Horizontal splits require more tooling, organizational structure changes, and coordination.
9. Vertical splits are easier to pick up if you have experience with single-page applications.
10. Both approaches can be mixed and matched depending on the application's needs.
11. Horizontal and vertical split approaches for micro-frontends have different pros and cons.
12. In horizontal split, there are challenges in organizational structure and ensuring the application works as a whole.
13. Vertical split is more comfortable for those with experience in single-page applications.
14. Routing can happen on client-side or edge side, but server-side routing provides better decoupling.
15. Blue-green deployment and strangler pattern are possible solutions for migrating legacy apps to micro-frontends.


## Building Micro-Frontends • Luca Mezzalira & Lucas Dohmen • GOTO 2022

URL: [https://www.youtube.com/watch?v=DG9puFuUb7E](https://www.youtube.com/watch?v=DG9puFuUb7E)

 1. App shell is a lightweight application framework for micro-frontends, handling loading, routing, and delinking.
2. Using multiple frameworks in micro-frontends can be beneficial but may impact performance and user experience; carefully consider the pros and cons.
3. Agility and modularity are crucial for businesses and architects when building micro-frontends.
4. Module Federation enables communication between webpack bundles, allowing code sharing among micro-frontends.
5. Framework updates can be costly, and some frameworks may become obsolete; consider the tradeoffs.
6. Modularity and agility are important for businesses.
7. Webpack's Module Federation allows independent micro-frontends to align on build tool versions.
8. Iframes provide strong boundaries and control over code, useful in integrating different companies' applications or security-sensitive industries.
9. Latest Federation approach: Independent micro-frontends using webpack, aligned on build tool version.
10. Web components offer custom components and Shadow DOM compatibility with various frameworks, enabling evolutionary architecture.
11. Components have context provided by the container, while micro-frontends define input/output without relying on container instructions.
12. CSS class name collisions can be handled using graphics or Shadow DOM for isolation.
13. Handling shared style data: Encapsulate styles in Shadow DOM, use BEM for granular styling, or graphics strategy for mix and match styling.
14. Include base styles in each Shadow DOM or app shell; decide tradeoffs between duplication and potential runtime errors.
15. SSI (Server Side Includes) and ESI (Edge-Side Includes): Server-side markup languages that use transclusion for content replacement.
16. Self-contained Systems guideline focuses on vertical splits, server-side routing, and integrating systems using transclusions or components from other systems.
17. Micro-frontends differ as they focus on an application shell and business domain.
18. Service dictionary approach decouples micro-frontends from endpoints by injecting a list of available services for each version.
19. API gateway: Expose APIs for different teams, maintaining independence while still communicating effectively.
20. Backend for frontend (BFF): A pattern that allows front-end teams to create layers between APIs and the front end, reducing cascading effects when updating APIs.
21. Team structure: Context should drive team organization, with regular checks on whether current models are still valid.
22. Architecture evolution: As companies change, architecture needs to adapt accordingly; question past decisions and be open to change.


## Expert Talk: Web Development & Its Failures • Kevlin Henney & Stefan Judis • GOTO 2021

URL: [https://www.youtube.com/watch?v=jQ0_bIVhkLk](https://www.youtube.com/watch?v=jQ0_bIVhkLk)

 1. Lars, Stefan, and Kevlin discuss the current state of web development, including increased complexity leading to issues like bloated code and performance problems.
2. Google's focus on performance metrics pushes developers towards more efficient solutions.
3. Understanding dependencies and vulnerabilities is crucial for maintaining software agility and security.
4. Complexity in software development leads to issues like performance, security vulnerabilities, and reduced agility.
5. Dependency management plays a significant role in the ecosystem.
6. Responsibility for these issues lies with everyone involved: developers, tool vendors, site providers, etc.
7. Cultural change within organizations can help improve practices and encourage better habits among developers.
8. Numbers and statistics provide insight into the current state of software development and security.
9. Importance of responsibility in data and software engineering.
10. Need for collective understanding and good user experience.
11. Cultural impact on software development.
12. Learning from failures, such as the NPM Left Pad incident.
13. Desire for frameworks to provide more self-containment.
14. Balancing between using frameworks and simple coding problems.
15. Importance of understanding customers' specific problems and tailoring solutions accordingly.
16. The need for evaluating trade-offs in every decision, considering the value it brings over time.
17. Acknowledging that what was good code in one context may not be suitable in another due to changes in technology or business needs.
18. Importance of slowing down and being aware in decision making.
19. Trade-offs change over time, what was good before may not be now.
20. Awareness is key to revisiting decisions based on changing contexts.
21. Responsibility comes with dependencies, considering trade-offs and boundaries.
22. JavaScript ecosystem has issues with duplication due to its rapid evolution and the NPM ecosystem.
23. People tend to copy code from others when learning, which can lead to duplication.
24. Tooling can help with awareness and identifying duplicate code.
25. Communication is crucial for understanding why certain decisions were made.
26. There's no one-size-fits-all approach; each situation should be evaluated individually.
27. Duplication is not always bad; it can help identify patterns and abstractions.
28. Tools should extend human capabilities, not dictate workflow.
29. Learning from observations and iterations can lead to better understanding.
30. Keeping an eye on potential issues and allowing time for insights.


## The Ideal Programming Language • Richard Feldman & Erik Doernenburg • GOTO 2021

URL: [https://www.youtube.com/watch?v=MPyUvtPFDSg](https://www.youtube.com/watch?v=MPyUvtPFDSg)

 1. The ideal programming language depends on the problem domain.
2. Richard prefers Elm for frontend web development and is working on a server-side language with ergonomic type checking.
3. Erik agrees that memory management should be left to machines, preferring automatic reference counting or Rust's borrow checker.
4. Both appreciate languages that allow functional and object-oriented programming.
5. Some people struggle with functional programming due to familiarity with object-oriented concepts.
6. Functional programming can be useful for transforming data between different systems.
7. Humans enjoy classification, but it may not always benefit code productivity.
8. Premature abstraction and overuse of inheritance can lead to unnecessary complexity.
9. Testability should be considered during language design.
10. Rust's approach to package manager and unit testing integration is an inspiration for other languages.
11. Discussions on language design and testing, Rust's package manager and unit test integration, automatic reference counting vs ownership systems, tracing garbage collection, compacting malloc implementation, Apple's hardware-level optimizations for automatic reference counting, cyclical dependencies, concurrency models, parallel programming, SIMD algorithms, Rust, Roc, Zig languages, ThoughtWorks focus on Kotlin and WebAssembly, WebAssembly use cases, JavaScript, CoffeeScript, TypeScript, in-house IT systems, Blazor, C#, performance importance for web applications, large organizations' internal application usage.


## Functional Programming for Pragmatists • Richard Feldman • GOTO 2021

URL: [https://www.youtube.com/watch?v=3n17wHe5wEw](https://www.youtube.com/watch?v=3n17wHe5wEw)

 1. Functional programming emphasizes immutability, pure functions, and functional languages.
2. Advantages include caching, pre-computing, and predictable code; disadvantages involve parallelization and memory usage challenges.
3. Pure functions are crucial in functional programming, enabling memoization for performance gains.
4. Functional languages benefit from caching and pre-computation due to their pure function nature.
5. Memoizing impure functions may lead to inconsistent results.
6. Precomputing is an optimization technique that improves performance by calculating values at build time with known constants or function calls on constants.
7. Pure functions guarantee consistent results and can be memoized, making them ideal for functional programming.
8. Parallelization is a key aspect of functional programming, allowing pure functions to run concurrently without data races or thread safety concerns.
9. Managed effects offer asynchronous abstractions like promises in other languages, providing more control over task execution.
10. Pure functions minimize side effects and reduce flaky tests; Elm has had zero flaky tests since 2015 due to its pure functional nature.
11. Effects can be tested using simulation instead of mocking.
12. Functional programming promotes better testing practices, development experience, and debugging ease.
13. Pure functions have explicit dependencies and are easier to debug than global mutable variables.
14. Side effects introduce implicit dependencies and make debugging more challenging.
15. In a pure functional style, the search space for potential culprits is smaller.
16. Explicit dependencies can be more verbose but offer clear boundaries in pure functions.
17. Deeply nested functions with side effects require all levels to return tasks, leading to potential issues.
18. Functional programming offers benefits such as caching, parallelization, testing, code revision, debugging, and ecosystem advantages.
19. Pure functional programming reduces debugging time and provides predictability.
20. Elm's ecosystem guarantees 100% pure functions, offering confidence in code quality and performance.
21. As a pragmatist, the speaker prefers functional programming for most tasks but appreciates other styles like imperative programming.


## AccessibleJS • Jemima Abu • GOTO 2021

URL: [https://www.youtube.com/watch?v=9SFSJDIg4KE](https://www.youtube.com/watch?v=9SFSJDIg4KE)

 1. Accessibility is the practice of building products that everyone can use, regardless of their abilities.
2. Web accessibility focuses on navigation, auditory, visual, sound, and motor capabilities for people with disabilities.
3. Importance of accessibility: Understanding how people with disabilities use technology.
4. JavaScript and accessibility: Javascript can be used to display content, communicate updates to screen readers, and handle navigation.
5. Accessible JavaScript examples:
   - Hiding/showing content: Use the hidden property for screen reader communication.
   - Timed content: Set aria live property to polite or forceful for screen reader updates.
   - Navigation: Ensure focusable elements are in logical order and accessible via keyboard navigation.
6. Demonstrate how to handle content for screen readers and constant updates.
7. Create custom elements with proper tab indexes, focusing on semantic elements.
8. Include skip to main content links for easier navigation.
9. Update focus when necessary, ensuring users can interact with hidden elements.
10. Handle interaction by considering both mouse and keyboard events.
11. Test accessibility during development to ensure a smooth user experience.
12. Handle handler events in JavaScript: Ensure equal keyboard and mouse events for custom elements.
13. Testing accessibility: Use tools like Lighthouse, Wave Web Accessibility Evaluation Tool, ChromeVox, Ally.js, and Accessible JS resources.
14. Maintain an accessibility checklist to ensure proper coding practices.
15. Read more on accessible JavaScript with helpful articles and resources.
16. Understand WAI ARIA Authoring Practices for creating custom elements with appropriate roles.


## Explosive Velocity with a Modern Stack • Tejas Kumar • GOTO 2021

URL: [https://www.youtube.com/watch?v=KTkyQ3z7M8w](https://www.youtube.com/watch?v=KTkyQ3z7M8w)

 1. Focus on front-end components: Next.js, Tailwind CSS, and Typescript
2. Benefits include structure, predictability, and performance
3. Next.js handles routing, rendering methods, and code splitting for faster delivery
4. Tailwind CSS offers atomic classes, auto-completion, and only ships used rules
5. Typescript provides ahead-of-time compilation, auto-completion, and error protection
6. Create a project with dependencies for speed across the stack
7. Use Next.js for routing and page creation
8. Build a To-Do list app using HTML, CSS, and JavaScript
9. Leverage React's declarative abstraction for better user interaction
10. Manage state of the To-Do list with useState hook from React
11. Use Tailwind CSS for styling and responsiveness
12. Utilize TypeScript to ensure predictable code behavior and auto-completion
13. Create a To-Do list app with React, checkboxes, text input, and manage state using hooks
14. Use Back4App (Kasura) as backend service for free database and API
15. Create 'to-do items' table in the database and query/mutate data from it
16. Demonstrate how to use GraphQL with auto completion for efficient development
17. Added mutation to database, creating a ToDo item
18. Fetched data from the database and set it in state
19. Debugged issues with adding new ToDos to the database
20. Switched to Tailwind for styling improvements
21. Updated tailwind initialization by including necessary files
22. Scalability can be achieved through hosting options like AWS, GCP, and Heroku
23. Predictable code leads to velocity
24. Utilized tools like Hasura and Heroku for load handling


## The Power & Performance of Phoenix LiveView • Geoffrey Lessel • GOTO 2021

URL: [https://www.youtube.com/watch?v=-Rl-26JJ6js](https://www.youtube.com/watch?v=-Rl-26JJ6js)

 1. Phoenix Live View is a real-time web framework built on Elixir, offering minimal JavaScript requirements and efficient performance.
2. Benefits include server-rendered HTML, form validation, reusable components with state, live navigation, and distributed capabilities.
3. The speaker shares their experience using Phoenix Live View to create a real-time stock updates web application.
4. Traditional page controllers were replaced by live views for interactive functionality without manual refreshing.
5. Key concepts of Elixir and Phoenix include assigns, router, and live view templates.
6. The speaker converted their Phoenix app to live view using generators for real-time communication.
7. They implemented a fake database with a publish-subscribe mechanism for updating prices every two seconds.
8. Subscriptions were handled in the socket's connected function.
9. Real-time communication between server and client was achieved, along with adding a live chat feature.
10. Handling submitted comments from forms was managed asynchronously.
11. Temporary assigns were used for efficient handling of large user data.
12. Updating socket connections with new comments without explicit handling.
13. The speaker demonstrated real-time chat using temporary assigns in Phoenix Live View.
14. Testing high update frequencies (1 second, half a second, 200 milliseconds, and 16 milliseconds) to test Elixir and Phoenix limits.
15. Browser handling of high update frequencies was observed.
16. Rendering S&P 500 list with prices updated every 200 milliseconds was demonstrated.
17. Live View's diffing algorithm efficiently handles changes in real-time updates.
18. The book "Phoenix in Action" provides information on using Phoenix and Live View.
19. A discount code for Manning books is available.
20. Speaker's contact details and resources shared.


## Svelte - Web App Development Reimagined • Mark Volkmann • GOTO 2021

URL: [https://www.youtube.com/watch?v=4CGzFwHoD0A](https://www.youtube.com/watch?v=4CGzFwHoD0A)

 1. Svelte is a compiler-based web framework with no dependencies and no virtual DOM, offering efficient performance.
2. StealthKit builds on top of Svelte, providing features like file-based page routing, REST services, layouts, code splitting, hot module reloading, static pages, tooling support, and serverless functions through adapters.
3. To get started with StealthKit, use 'npm init svelte' for project creation and configuration, followed by development mode ('npm run dev') and deployment ('npm build'). Code quality checks are done using 'npm run lint' and 'npm run format'.
4. A sample ToDo app demonstrates StealthKit's functionality, allowing users to add tasks, mark them as done, and clear completed tasks.
5. Svelte uses components with three sections: JavaScript code, HTML content, and CSS styling. Data flows between components using props and events.
6. The topmost component manages the entire app, importing the ToDo component and handling its state.
7. Svelte is fast, lightweight, and has small bundle sizes with file-based component definitions, clear global styling, efficient updates through reactive declarations, and state management using stores.
8. Reactive statements simplify code and make animations easier while optimizing performance.
9. Stores manage data outside components, offering four types: writable, read-only, derived, and custom.
10. Svelte's popularity is growing but not as fast as other frameworks; however, it offers an improved developer experience.
11. Related tools include VS Code extension, SvelteKit (in beta), testing libraries, Smelt Native for mobile apps, and learning from Rich Harris' talk on rethinking reactivity.


## The Jamstack Book • Brian Rinaldi & Raymond Camden • GOTO 2021

URL: [https://www.youtube.com/watch?v=x0RoXonhldk](https://www.youtube.com/watch?v=x0RoXonhldk)

 1. Jamstack is a web development approach focused on static websites with dynamic features.
2. Key components include static site generators, CICD process, and deployment to edge servers/CDNs.
3. Complexity has evolved over time with tools like Next, Nuxt, Gatsby, incremental static regeneration, and distributed persistent rendering.
4. The goal is to simplify deployment while still offering dynamic features.
5. Jamstack has become more complex with features like distributed persistent rendering and incremental static regeneration.
6. Complexity is moving closer, allowing users to manage it locally rather than on a CDN.
7. WordPress caching can be complicated for some users.
8. Atomic builds and deploys in Jamstack prevent issues during site building.
9. Large companies with complex websites are adopting Jamstack, leading to changes in the technology.
10. E-commerce is now supported by Jamstack.
11. Static sites were once limited in their applications, but Jamstack can be used for almost anything.
12. User-generated content and more complicated solutions are possible with Jamstack.
13. Popular tools include Eleventy for static site generation and Netlify for deployment.
14. Hugo and Next.js are also used for specific projects depending on requirements.
15. The future of Jamstack may see more debate about its definition, potentially expanding to include edge deployments and tooling.
16. A book on Jamstack is available through Manning Early Access Program, with a physical book release expected in fall.


## Did We(b Development) Lose the Right Direction? • Stefan Judis • GOTO 2020

URL: [https://www.youtube.com/watch?v=0Vtoblyq8fE](https://www.youtube.com/watch?v=0Vtoblyq8fE)

 - 10 years of web development journey
- Frontend evolution from build tools to universal JavaScript frameworks
- Personal website built with modern best practices, but not the fastest
- Comparison with an older website: simpler HTML, fewer resources, and better performance
- Lighthouse performance score calculation: first contentful paint, time to interactive, speed index, largest contentful paint, total blocking time, cumulative layout shift
- JavaScript's impact on browser performance - Lighthouse performance score is calculated based on six metrics.
- Single threaded browser environment can cause frustration for users.
- Overly optimized websites may not be necessary, as they add complexity and slow down the user experience.
- Universal JavaScript apps might not be ideal for content sites, as they can lead to slower performance when heavy resources are added.
- Strive for simplicity in web development to ensure better user experience.
- Progressive enhancement is important for ensuring websites work without JavaScript.
- React documentation example shows that experience is similar with or without JavaScript, but the latter is lighter and faster.
- Average website page weight is 2MB, which can be expensive in some countries.
- Facebook and Gmail are examples of complex applications using app frameworks effectively.
- The web almanac shows that jQuery is still used on many websites despite newer frameworks being popular.
- Discusses the complexity of web development and its impact on user experience, highlighting accessibility, speed, and security as important factors for building great sites.
- Mentions misuse of HTML as a common issue leading to accessibility problems.
- Only 6% of websites use Content Security Policy (CSP) for added safety.
- Criticizes the current JavaScript ecosystem with its reliance on packages and vulnerabilities.
- Concludes that the web is losing quality due to these issues.
- Web accessibility issues are common due to misuse of HTML, with 98% of websites having some problems.
- The complexity of modern web development tools can lead to bloated projects.
- There's a need to focus on fundamentals like HTML, CSS, and JavaScript for better user experiences.
- Consider splitting frontend roles into javascript engineers and UX engineers.
- Ultimately, the goal should be to provide good user experiences regardless of technical implementation.
- The speaker discusses the complexity of choosing frameworks and their impact on job markets.
- They suggest that the term "front-end developer" may not be accurate anymore, as there are two distinct camps: engineers focused on tools like React and those concerned with HTML, usability, and accessibility.
- The speaker argues for prioritizing user experience over developer experience.
- He shares his personal experience of simplifying a project by dropping universal JavaScript in favor of a pure implementation.
- Developers should focus on building sites that just work and worry less about the technology used to achieve this goal.


## HTTP/3 Is Next Generation HTTP. Is It QUIC Enough? • Daniel Stenberg • GOTO 2020

URL: [https://www.youtube.com/watch?v=pUxyukqoXR4](https://www.youtube.com/watch?v=pUxyukqoXR4)

 - HP1 and 2: Challenges with TCP, HTTP1, and ossification
- Quick (new transport protocol): Improves performance, security, flexibility
- Key features of Quick: Multiplexing, connection migration, congestion control
- HP3: Built on top of UDP, expected deployment soon
- Quick replaces TCP for HTTPS traffic
- HTTP 3: First application protocol on Quick (similar to HTTP 2)
- Stack change from TCP/TLS to UDP and Quick
- Deploying HTTP 3 has challenges due to CPU usage and unoptimized UDP stacks
- OpenSSL's quick implementation delay affects other libraries
- New tools needed for understanding encryption and protocols
- HTTP 3 finalization by early 2021, slower adoption possible
- Quic: new transport protocol aiming to replace TCP (expected release in early 2021)
- Quic uses UDP for its transport layer instead of TCP
- Ongoing discussions about multipath support and improvements within Quic
- Several companies have implemented HTTP/3 in their products
- Wireshark can decrypt and analyze latest Quic versions
- Browsers like Chrome, Edge, Firefox, Safari, Cloudflare CDN support experimental features for enabling HTTP/3


## Going Static in a Dynamic World with Hasura and Nuxt.js • Debbie O'Brien • GOTO 2020

URL: [https://www.youtube.com/watch?v=1j9DIX32GpY](https://www.youtube.com/watch?v=1j9DIX32GpY)

Error


## HTML: How to Make Loveliness • Bruce Lawson • GOTO 2020

URL: [https://www.youtube.com/watch?v=L83LVfhTbzg](https://www.youtube.com/watch?v=L83LVfhTbzg)

 1. Use HTML properly for better performance, accessibility, and responsiveness.
2. Learn semantic HTML to write better code.
3. Utilize appropriate tags like header, nav, main, article, and footer for easier navigation and accessibility.
4. Employ semantic HTML elements for better accessibility and search engine optimization.
5. Accessibility benefits everyone, not just people with disabilities.
6. Test websites for low contrast, missing alternate text, empty links, form labels, and empty buttons.
7. Choose accessible component libraries like Reach UI, Tourment UI, and Lion.
8. Reduce JavaScript usage to improve website performance and user experience.
9. WebAIM found 98% of websites have accessibility errors.
10. Common issues include low contrast, missing alternate text, empty links, missing form labels, and empty buttons.
11. Use HTML/CSS instead of JavaScript when possible.
12. Test sites without JavaScript and enhance them with JS.
13. Choose libraries carefully; some are tested with assistive technologies while others aren't.
14. Beware of bloated JavaScript files that slow down websites for users on limited data plans.
15. Make the web accessible to everyone, especially those in developing countries where internet access can be life-changing.


## Adopt GraphQL without Writing any Backend Code • Uri Goldshtein • GOTO 2020

URL: [https://www.youtube.com/watch?v=1bJ_M_v-tso](https://www.youtube.com/watch?v=1bJ_M_v-tso)

 - GraphQL is a powerful query language that abstracts data fetching and orchestration.
- Gradual adoption of GraphQL can be done in three ways: 
  1. Use GraphQL on the client side, replacing manual code with automatic queries.
  2. Integrate GraphQL into existing APIs by using libraries like Apollo Server.
  3. Build a new API from scratch using GraphQL as the foundation.
- Benefits of adopting GraphQL include improved developer productivity and easier UI development.
- GraphQL simplifies development by reducing code and automating data fetching.
- Apollo can be used as a client with its own graphical engine, allowing for local data storage or REST requests.
- GraphQL Mesh converts existing APIs into GraphQL without affecting the source, enabling querying from multiple sources.
- It allows querying multiple sources as if they were one GraphQL API, linking them together.
- The library runs on both client and server sides, making it flexible for use in various scenarios.
- It supports numerous sources and offers customizations to fit specific needs.
- Gradually integrating GraphQL Mesh into your stack can help automate manual coding and improve efficiency.


## Advanced Feature Flagging: It's All About The Data • Dave Karow • GOTO 2020

URL: [https://www.youtube.com/watch?v=f8XDvtfKWQE](https://www.youtube.com/watch?v=f8XDvtfKWQE)

 - Feature flags enable separating code deployment from feature release.
- Gradual rollouts and randomized controlled trials help account for outside factors in measuring results.
- Attribution assigns users to different cohorts, while statistical analysis proves or disproves significance of changes.
- Experimentation platforms combine feature flags with data analytics for a more reliable process.
- Targeting features include fast, randomized, and sticky user assignment for different experiences.
- Telemetry collects data on user behavior and feature usage.
- Statistical analysis uses t-tests to compare distributions and determine if results are significant.
- Management consoles provide a consistent way for teams to manage rollouts and review metrics.
- Examples of companies with powerful experimentation tools: Walmart (Expo), LinkedIn (LinkedIn Experimentation or Licks), Booking.com.
- Trustworthy Online Controlled Experiments book offers lessons on effective experimentation practices.
- Split provides an off-the-shelf experimentation platform for engineering teams to release software efficiently.


## Clean Architecture with ASP.NET Core 3.0 • Jason Taylor • GOTO 2019

URL: [https://www.youtube.com/watch?v=dK4Yb6-LxAk](https://www.youtube.com/watch?v=dK4Yb6-LxAk)

 1. Clean architecture separates domain and application layers, with dependencies pointing inwards to isolate core logic.
2. Infrastructure is independent of frameworks, allowing for easier maintenance and scalability.
3. Northwind Traders solution template on GitHub provides a practical example.
4. Domain layer contains entities, value objects, enumerations, and custom exceptions.
5. Application layer has business logic, interfaces, and implementation classes.
6. Presentation layer handles UI concerns.
7. Infrastructure layer manages external dependencies like data access and logging.
8. Merge domain, application, and infrastructure layers for simplicity if desired.
9. Use value objects to represent complex types with specific logic.
10. Initialize collections to enforce good practices and simplify code.
11. Create custom exceptions for expected domain events.
12. Include auditable entity base class for automatic tracking of changes.
13. Provide sample unit tests for guidance on working with value objects.
14. Apply CQRS (Command Query Responsibility Segregation) to improve performance, scalability, and simplicity.
15. Utilize mediator pattern for easy addition of behavior in application layer.
16. Organize code by feature with common folder for shared behaviors.
17. Encapsulate business cases within single folders for easier maintenance and less breaking changes.
18. Demonstration of a solution explorer, query handler, and co-locating code for a specific business case.
19. Implemented cross-cutting concerns such as request logging, validation, and mapping behavior.
20. Used C# 8 interfaces with default implementations to simplify mapping between entities and DTOs.
21. Created a mapping profile for automatic configuration of mappings.
22. Tested the mapping functionality using unit tests provided by AutoMapper.
23. GTO has a mapping method and uses C# 8 interfaces for configuration.
24. Automapper simplifies mappings and projections, while dependency injection handles application dependencies.
25. Infrastructure layer includes persistence, identity, services, and API clients.
26. Experts disagree on the need for repository and unit of work patterns; use them if they solve a problem.
27. Fluid API configuration is simple with F Core 1.0.
28. Asp.net core identity version 3+ requires leaving base statement in configurations.
29. Entity Framework Core used for data access, with Fluent API configuration.
30. Prefer conventions over configuration.
31. Presentation layer has well-defined view models and queries/commands.
32. Clean architecture approach using CQRS to separate logic from controllers.
33. Infrastructure controller is simple, focusing on request-response handling.
34. Open API uses Swagger for specification, client generation, and bridging frontend/backend.
35. Exception middleware handles errors with meaningful responses.
36. Integration tests ensure high-level functionality.


## HTTP/3 is next Generation HTTP. Is it QUIC enough? • Daniel Stenberg • GOTO 2019

URL: [https://www.youtube.com/watch?v=rlN4F1oyaRM](https://www.youtube.com/watch?v=rlN4F1oyaRM)

 1. HTTP has evolved over time, with issues in earlier versions like TCP connections and header blocking problems.
2. HTTP 2 addressed these issues by using one connection for multiple streams but introduced new challenges due to packet loss affecting all streams.
3. Quic (Quick UDP Internet Connections) is a new protocol that aims to solve the problems with TCP and HTTP/2, using UDP instead of TCP for faster and more reliable performance in certain situations.
4. Quic is still under development but has potential to become the next generation of HTTP.
5. QUIC can be used for HTTP/3, making the internet faster and more efficient.
6. Google's experimentation led to a new transport protocol called QUIC (Quick UDP Internet Connections), which is now being standardized by IETF.
7. QUIC is built on top of UDP, adding reliability and security features. It uses streams for better performance and flexibility compared to TCP/TLS.
8. HTTP 3 (H2P) is an application layer built on top of QUIC, providing similar functionality but with a different wire format.
9. Quic aims to become a potential TCP replacement in the future.
10. Independent streams allow for better handling of network issues, prioritization, and early data transmission.
11. Quick connections require verification of host certificates.
12. Google and Facebook report 3-7% connection failure rate with quick. Fallback mechanisms are needed due to UDP blocking by some organizations.
13. CPU intensive for servers; efforts underway to improve performance.
14. UDP traffic is blocked by many organizations due to DDoS attacks. Fallback mechanisms for failed connections are complicated and vary based on network topology.
15. Google Quick (QUIC) is a new protocol that aims to improve performance over UDP, but it needs standardization and better tooling.
16. QUIC has been implemented in various browsers and servers, with some limitations. The process of shipping QUIC is ongoing, with the working group aiming for July 2019 release.
17. Browser support for QUIC will depend on its stability and integration into Linux distros.
18. HTTP/3 is in development, facing challenges such as TLS support and integration into Linux distros.
19. Quick (UDP-based protocol) could be a potential TCP replacement for more protocols in the future.
20. WebSockets are not part of HTTP but can be adapted to work with HTTP/3.
21. Encrypted quick over UDP is another new transport protocol being developed, facing challenges on both service and client sides.


## You Really Don't Need All that JavaScript, I Promise • Stuart Langridge • GOTO 2019

URL: [https://www.youtube.com/watch?v=rxlJRydqmk8](https://www.youtube.com/watch?v=rxlJRydqmk8)

 1. Importance of web performance: Alex Russell emphasizes the need for better performance.
2. First meaningful paint (FMP): Measures how quickly content appears on a page, not just loading time.
3. Server-side rendering vs client-side: Serving less HTML doesn't necessarily improve FMP.
4. Network issues: 1% of users don't get JavaScript enhancements due to network or browser issues.
5. User experience: Focus on happy readers and ensure websites load properly for all users regardless of circumstances.
6. The modern web is complex, but frameworks and libraries provide benefits like reusability, consistency, and engineering principles.
7. However, they can also lead to fatigue due to constant changes in technology.
8. Maintaining a good user experience is crucial despite the challenges of modern web development.
9. The evolution of web frameworks aims to control loading experiences through portals.
10. Portals are simple solutions that allow users to navigate within an iframe without losing browser support.
11. Portals can be used for various purposes like creating documentation pages with separate panes.
12. The main advantage of portals is that they are just HTML elements and can be controlled by the developer, unlike complex frameworks.
13. Portal concept can be used for progressive enhancement, allowing separate pages to work together.
14. Portal enables simultaneous access to both the current and next page, providing better control over navigation.
15. This approach uses standard HTML with minimal JavaScript enhancements.
16. Portal is currently non-standard but may become a part of future web standards.
17. It can be used for websites that don't require full single-page apps, offering more flexibility in design and development.
18. Stay updated with industry trends but don't feel pressured to use every new technology.
19. Frameworks can be useful for prototyping ideas before standardization.
20. Polyfilling can help get features in people's hands without waiting for standardization.
21. Be conservative regarding performance and accessibility when using frameworks.


## UX Tips to Avoid Losing Users' Attention • Chris Atherton • GOTO 2019

URL: [https://www.youtube.com/watch?v=-pixBU3EJfU](https://www.youtube.com/watch?v=-pixBU3EJfU)

 1. Attention is crucial in user experience design, as it determines where users focus on a page.
2. Visual weight and detail influence attention; strong call-to-action buttons can be distracting if they overshadow other important information.
3. Rhythm, tempo, and layout affect how we perceive and process information.
4. Design user interfaces with attention in mind by using bold text, balancing size, color, and positioning to guide users effectively.
5. Executive function helps the brain manage tasks and resist distractions; keep instructions concise and well-formatted.
6. Attention is like a zoom lens, focusing on one thing while ignoring others; inattentional blindness can cause users to miss important details.
7. Design for accessibility by considering different needs and abilities, including those with ADHD, bipolar disorder, dyslexia, low vision, etc.
8. Balance visual weight, size, and placement on pages to minimize issues when glitches occur; ensure websites function well even during disruptions.
9. Designing for attention benefits everyone, not just those with disabilities; avoid distracting animations, pop-ups, and complex layouts.


## Designing APIs for 150 Million Orders • Michele Angioni & Matt Fewer • GOTO 2019

URL: [https://www.youtube.com/watch?v=OB0Pb-nd0g8](https://www.youtube.com/watch?v=OB0Pb-nd0g8)

 - Takeaway.com operates in 12 countries, processing 42 million orders annually.
- Scoober manages delivery drivers and optimizes routes using logistics.
- Domain-driven design (DDD) helps separate concerns and improve scalability.
- DDD involves creating a common language, context mapping, and domain modeling.
- Scoober used DDD to clarify terminology and better understand their business model.
- Importance of a common terminology and language for effective software architecture.
- Domain Driven Design (DDD) concepts like context mapping to understand the domain better.
- Refactoring existing architecture using best practices, such as standardizing event payloads and authentication methods.
- Implementing role-based access control for authorization.
- Using error codes and clear formats in API responses.
- Monitoring and alerting strategies for real-time error handling.
- Versioning of synchronous communication through topic or event payload.
- The significance of good documentation for long-term maintainability.
- Maintain clear error messages and documentation for APIs.
- Use versioning, such as semantic versioning or timestamps, for synchronous communication.
- Test different environments: life, staging, load testing, and blue-green deployments.
- Focus on test automation through unit, integration, and end-to-end tests.
- Migrate to a new stack with modern technologies for better scalability, efficiency, and security.
- Improve time to market, deployment speed, performance, and stability.
- Implement behavioral testing to make data-driven decisions about UI design.
- Decouple services for clear separation of business domains.
- Consumer web project: migration to modern technologies, improve time to market, deployment, performance, security, and testing.
- Back-end for front-end (BFF): separate back-ends for each interface, shielding backend from front-end changes.
- Design system: centralized design framework with standards, documentation, UI patterns, and components.
- Challenges: status quo discovery, parallel development, reevaluating dependencies, experimentation without affecting existing apps.
- The speaker discusses a migration project involving building applications and implementing a centralized design framework called Snacks.
- They introduce their design system, which includes a React component library, color library, icon library, and documentation.
- To implement the design system gradually without disrupting existing websites, they plan to rebuild pages on a page-by-page basis.
- The benefits of this approach include low risk for the business, easier hiring due to using popular technologies, domain separation, and better developer experience.
- They emphasize the importance of careful planning and designing infrastructure for long-lasting solutions.


## DevUX: Improving Developer-Designer Collaboration • Yu Ling Cheng & France Wang • GOTO 2019

URL: [https://www.youtube.com/watch?v=uWIfnPc1wC0](https://www.youtube.com/watch?v=uWIfnPc1wC0)

 1. Dev UX is a practice that focuses on improving collaboration between designers and developers, leading to better products faster.
2. There are four levels of Dev UX: Ground Zero, Level 1 (basics), Level 2 (efficiency), and Level 3 (symbiosis).
3. Clear communication, understanding each other's roles, and defining responsibilities are crucial for a successful team.
4. Designers should provide developers with necessary assets like SVG files instead of PNGs to streamline the development process.
5. Centralize design handoff to ensure all needed information is available for developers.
6. Objectives: Create a process that works for the team, ensuring everyone is updated with relevant information.
7. Missing assets: Understand developers' needs alongside mock-ups and centralize everything in design handoff.
8. Collaboration: Work together next to each other, creating vocal communication.
9. Level 1 challenges: Ensure designers use real sets of data for mock-ups, involve developers for technical insights, and avoid dummy text.
10. Populating designs with real data: Use tools like Craft from Envision to simplify the process.
11. Provide real data for mockups and involve developers.
12. Use tools like Sketch, Figma, and style guides to simplify design processes.
13. Define breakpoints for responsive designs.
14. Create user flows for complex features.
15. Integrate style sheets with linting tools for consistency in coding.
16. Strive for efficient collaboration between designers and developers.
17. Be detail-oriented and fix inconsistencies within the app.
18. Provide real data to designers during feature development.
19. Involve developers and use a common language with style guides.
20. Aim for efficiency by reducing friction points.
21. Good teams communicate, react, and iterate together.
22. Identify small inconsistencies that slow down the team.
23. Share design patterns to improve efficiency.
24. Split components in the same way for better integration.
25. Use tools like Zeppelin's Stiga to link mockups with code.
26. Explore plugins to bridge the gap between designers and developers.
27. Importance of collaboration between designers and developers.
28. Sharing common design patterns for better communication.
29. Involving everyone in the conception, design, and decision process.
30. Understanding each other's roles and experiences.
31. Building trust within teams through open communication and vulnerability.
32. Organizing events like Designer UX Drinks to foster understanding between designers and developers.
33. DevUX.tech website with manifesto, tools, and resources for fostering dev/UX culture.
34. Joining Slack or Twitter communities to share experiences and get help (no context).


## The Future of Machine Learning & JavaScript • Asim Hussain • GOTO 2019

URL: [https://www.youtube.com/watch?v=vfmGII9mGmY](https://www.youtube.com/watch?v=vfmGII9mGmY)

- The speaker shared his journey into machine learning through JavaScript applications.
- He introduced AI J ROCKS, a website with various JavaScript projects incorporating AI.
- Emoji Fire is an example application that detects facial features and emotions in images to replace faces with appropriate emojis.
- Emotion detection involves identifying facial features and using neural networks.
- Neural networks consist of layers, weights, and activation functions; training involves backpropagation.
- APIs like Microsoft's Face API use neural networks for emotion detection.
- TensorFlow.js enables machine learning in the browser with JavaScript.
- Pretrained models can be loaded for image recognition using tools like TensorFlow.js.
- Microsoft's Computer Vision API provides detailed descriptions of images.
- A tool could be created to automatically add alt properties to images based on their descriptions.
- MobileNet is a lightweight model for image recognition but lacks accuracy.
- Microsoft's Computer Vision API offers detailed human-readable descriptions of images.
- Sarah Dresner's demo demonstrates an AI that can generate images based on outlines using Generative Adversarial Networks (GAN).
- GAN consists of a generator and discriminator neural networks competing to improve their performance.
- The generated model can be exported for further optimization and use in the browser.
- GAN can be trained to generate images of anything, making it versatile.
- Generative neural networks create new images based on input data.
- TensorFlow JS is a tool for building generative models in the browser.
- A book titled "Touch the Machine: TensorFlow JS" teaches about using TensorFlow JS.
- The Mojo Fire tutorial demonstrates how to build a text generator.
- Slack bots can be created with step-by-step guidance, from API integration to creation.


## Fast by Default: Near Instant Load Times at Scale with GatsbyJS • Nicolas Goutay • GOTO 2019

URL: [https://www.youtube.com/watch?v=p14g-Sep7HY](https://www.youtube.com/watch?v=p14g-Sep7HY)

 1. Web performance impacts businesses in various ways, including revenue growth and user engagement.
2. Examples of companies benefiting from improved web performance: Zalando (0.7% revenue increase), Trainline (8 million pounds more annual revenue), Financial Times (30% more engaged users), BBC (10% less users lost due to slow load times), Pinterest (15% SEO traffic and conversion rate increases).
3. Web performance is also an ethical issue, as poor performance can lead to exclusion of users with slower devices.
4. Over the years, web development has evolved from static sites to server rendering, client-side rendering, rehydration, pre-rendering, and Gatsby JS. Each approach has its advantages and disadvantages in terms of performance, user experience, and device load.
5. Gatsby JS combines the advantages of static site generators and progressive web apps by handling both static and dynamic data at build time using plugins. It offers performance optimization features like image optimization, code splitting, linked prefetching, and native lazy loading.
6. The framework aims to make building fast websites easy without worrying about performance.
7. Third-party scripts can negatively impact website performance.
8. Monitoring web page performance is crucial to maintain speed. Tools like WebPagetest and Falco help test website performance across different locations, devices, and user journeys. They provide detailed data for debugging issues and catching regressions.


## WebAssembly Beyond the Browser • Dan Callahan • GOTO 2019

URL: [https://www.youtube.com/watch?v=TGo3vJVTlyQ](https://www.youtube.com/watch?v=TGo3vJVTlyQ)

 1. WebAssembly is a low-level programming language designed to address fundamental limitations of the web, enabling efficient compilation from various languages like C++, Rust, and Go into machine code that runs in browsers.
2. The goal is to create a single binary format for running on any platform without requiring compilation for each target architecture or operating system.
3. WebAssembly's potential impact extends beyond web development, potentially influencing edge computing, IoT devices, and distributed systems.
4. Libsass is an example of a library that compiles to WebAssembly, making it compatible with various platforms.
5. WebAssembly allows developers to compile once and distribute to multiple platforms without worrying about compatibility issues.
6. The goal of WebAssembly is to make the web more universal by supporting different languages and allowing them to work together seamlessly.
7. WebAssembly is a binary format that uses 256 operations, enabling efficient execution on various devices.
8. Static typing in WebAssembly helps optimize code execution.
9. Imports and exports allow connecting WebAssembly with other APIs safely.
10. Compilers can convert C/C++ to WebAssembly, enabling porting of game engines like Unreal and Unity to the web.
11. WebAssembly allows exposing browser APIs to WebAssembly modules, enabling compilation of C/C++ code for the web.
12. Demos show potential uses like running old software and games in browsers.
13. Practical use cases include reusing existing libraries on the web without remaking them in JavaScript.
14. WebAssembly offers more predictable performance compared to JavaScript, making it useful for specific compute-intensive tasks.
15. Projects like Sigma and MongoDB Compass are using WebAssembly for better performance and consistency across browsers.
16. WebAssembly is a standardized way to compile code into a binary format that can run on any browser.
17. It offers predictable performance and consistency across browsers, making it useful for compute-intensive tasks.
18. Rust, AssemblyScript, and Go are examples of languages that compile to WebAssembly.
19. Mozilla has created a standalone WebAssembly runtime called Wasmtime, which is small, embeddable, and fast.
20. The Bytecode Alliance aims to define the future of WebAssembly beyond browsers by creating standard libraries for various platforms.


## Internationalization is a Piece of Cake • Eli Schutze Ramirez • GOTO 2019

URL: [https://www.youtube.com/watch?v=nsGmQ0v36bo](https://www.youtube.com/watch?v=nsGmQ0v36bo)

 1. Internationalization is about designing content, applications, and specifications to work well for users from different cultures, regions, or languages.
2. It involves building flexibility into your code so that it can be easily adapted later on.
3. Some aspects to consider include language, writing systems, date/time/currency formatting, directionality, pluralization, grammar, and relative time.
4. Internationalization is part of accessibility as it ensures websites are accessible to users from all over the world.
5. Unicode is a standard that assigns each character a number, making content inclusive to everyone.
6. CLDR (Common Locale Data Repository) provides information about languages and regions, including date formats, time zones, and calendar details.
7. ICU (International Components for Unicode) is a library that helps developers handle internationalization in their applications.
8. Always let users choose their own locale to ensure inclusivity.
9. JavaScript has an Internationalization API that can format numbers, dates, and currencies.
10. FormatJS is a library built on top of CLDR and ICU message format with bindings for React, Ember, Handlebars, and Dust.
11. Internationalization is crucial for global apps but can be challenging due to logistics.
12. Use separate files for strings and consider continuous localization services.
13. Make your app flexible from the start by leaving placeholders for Strings.
14. Visual elements should also be considered early on in development.
15. Start internationalizing early to avoid costly redesigns later.
16. Internationalization is part of accessibility. Standards and acronyms help with proper implementation.
17. Start early in the design and development process for flexibility.
18. Consider languages like German for testing as they have long words that can break layouts.
19. Always prioritize user experience when localizing websites.


## Building Resilient Frontend Architecture • Monica Lent • GOTO 2019

URL: [https://www.youtube.com/watch?v=TqfbAXCCVwE](https://www.youtube.com/watch?v=TqfbAXCCVwE)

 - Reasons for rewriting software: inexperience, fun, better solutions, technical debt
- Recurring technical debt: code, tools, infrastructure
- Second system effect: refactoring can make new systems worse than the original
- Importance of good architecture: resilient to change, increasing speed of adding features
- Challenges with software architecture: lack of common definition, detachment from daily problems
- Reframe architecture as enabling constraints that help move faster and more safely over time.
- Examples of constraints include OOP, functional programming, and CSS in JS.
- Source code dependencies should be managed with rules to avoid the "big ball of mud" approach.
- Layered or modular approaches can help prevent unintended side effects and cross-team conflicts.
- Discussing directory structure and internal dependencies in apps.
- Big ball of mud vs layered approach: easier to isolate impact of changes, less cross team conflicts.
- Shared components: be conservative about code reuse; avoid coupling unrelated code.
- Enforcing boundaries: maintain documentation but ensure it's followed by the team.
- Focus on decoupling and simplicity rather than dryness for better code quality.
- Software changes require code to change too.
- Architecture can be seen as enabling constraints, helping apps evolve safely.
- Be conservative about code reuse and think critically about its context.
- Enforce architectural decisions through automation like forbidden dependency tests.
- Involve individual contributors in architectural decisions.
- Don't limit yourself to framework-specific solutions; learn from other programming communities.


## HTTP Headers for the Responsible Developer • Stefan Judis • GOTO 2019

URL: [https://www.youtube.com/watch?v=JfjiFsJsO4E](https://www.youtube.com/watch?v=JfjiFsJsO4E)

 1. The web connects people globally, making it essential to build for everyone.
2. HTTPS ensures secure connections and browser support, with high adoption rates.
3. Strict Transport Security (HSTS) can enforce HTTPS usage, preventing man-in-the-middle attacks.
4. Certificates are free, so websites should use HTTPS.
5. HSTS ensures encryption for a specific time period and CSP limits allowed content on your website.
6. SameSite cookies prevent third-party scripts from accessing cookies.
7. Consider data consumption across countries to ensure affordable web usage.
8. Discuss various headers and techniques to improve web performance, such as cache control, compression, WebP support, client hints, save data header, link rel preload, feature policy, optimized media headers for staging servers.
9. Feature policy controls website permissions, privacy, content blocking in browsers, and recommends developer tools like Google Lighthouse, Webhint, Weapons.
10. Strive for a safe, affordable, and respectful web experience for everyone.


## Vue and You • Matt Danforth • GOTO 2019

URL: [https://www.youtube.com/watch?v=n8ERFbkt_h8](https://www.youtube.com/watch?v=n8ERFbkt_h8)

 - History of web development: Mosaic, browser wars, JavaScript evolution.
- jQuery's impact on front-end development.
- Ajax and JSON's role in simplifying data exchange.
- Single Page Applications (SPAs) and their SEO challenges.
- Frameworks' pros and cons, constant change.
- Browser convergence: Improved compatibility, fewer coding challenges.
- Performance and accessibility considerations during development.
- Mobile first approach importance due to increasing mobile usage.
- Componentization for reusable code and flexible software.
- Considering factors before choosing a framework or tool.
- React's license change impact on decision making.
- Angular's lack of upgrade path affecting community perception.
- History lesson about JavaScript evolution from prototype to jQuery.
- Contributors' role in determining a framework's success.
- Live coding with View, focusing on creating an instance, HTTP request library, and pre-made components based on material design.
- Balancing adding state too soon or later.
- Beautify component library impact on performance.
- Next.js benefits for simplifying web development.
- Beautify's well-documented APIs and easy accessibility.
- Axios as an HTTP request handler for Ajax requests.
- Demonstration of creating a table using View, Axios, and Bootstrap components.
- Important aspects: data binding, state management, pagination.
- Comparison with other frameworks like React and Gatsby.
- Focus on developing in components, best practices, accessibility, and performance for great applications.
- Encouraging session ratings to improve the internet experience.


## ReasonML: React as a Language and what the Future looks like • Peter Piekarczyk • GOTO 2019

URL: [https://www.youtube.com/watch?v=xGN4BMPbk7Q](https://www.youtube.com/watch?v=xGN4BMPbk7Q)

 1. Draftbit, a platform for building mobile apps visually using Expo and React Native, has adopted Reason as its primary language due to its benefits.
2. The team moved from JavaScript to Reason for reasons including ease of use, reduced technical debt, and faster development.
3. They also integrated GraphQL and Apollo for better data management.
4. Their stack includes React, Reason, Expo, GraphQL, Apollo, Postgres, and WebAssembly.
5. Reason is a JavaScript-like functional language with a friendly compiler built on top of OCaml and uses NPM for package management.
6. Benefits include faster compilation, fewer errors due to static typing, easy integration with existing projects, and helpful error messages.
7. The ecosystem includes tools like Babel, Flux, Redux, Yarn, Immutable, Prettier, and TypeScript.
8. Reason is ten times faster than Babel in compiling real-world projects.
9. Draftbit uses React hooks as the future of development for a safer process and easier development.
10. Pattern matching with switch statements provides powerful data structure representation in Reason.
11. Variants offer a way to represent complex data structures through constructors and arguments.
12. Jen type decorator generates bindings between JavaScript and reason, simplifying onboarding for existing projects.
13. Reason allows using existing JavaScript components alongside reason code.
14. BuckleScript is a fast, efficient JavaScript compiler with deep integration with popular libraries.
15. Tree shaking in BuckleScript reduces the size of compiled JavaScript files significantly.
16. Deep integration with JavaScript libraries allows for efficient optimization and performance improvements.
17. The community can create bindings between Reason and JavaScript using specific syntax.
18. Companies such as Bloomberg, Messenger, Accenture, McKinsey & Company, Jane Street, and Drafted use Reason in production.
19. Join a Chicago meetup or join the Reason ML Google Discord to learn more about the framework.
20. A conference in October will feature Jordan Walke keynoting for the first time since releasing React in 2013.
21. Give BuckleScript a chance and explore its potential as an alternative to other JavaScript frameworks.


## Going Serverless with VueJS • Divya Sasidharan • GOTO 2019

URL: [https://www.youtube.com/watch?v=Mu9zKpGhX1Y](https://www.youtube.com/watch?v=Mu9zKpGhX1Y)

 1. Ordinary world: Sammy, a server worker, manages a popular pizza rating app.
2. Call to adventure: The app becomes very popular but crashes due to high traffic.
3. Initiation: Sammy tries to fix the issue by adding more servers, but it leads to wastage of resources and money.
4. Mentor: Swami server lot advises her on scaling without servers.
5. Crossing the threshold: Sammy rethinks her approach and decides to break down the monolithic app into smaller components.
6. Return: Sammy's company adopts a new architecture, using serverless technology, which helps them scale efficiently and save costs.
7. Challenge: Separate layers in an application called Chai Pie (pizza rating app).
8. Solution: Use serverless functions with Netlify for easier deployment and management of server code.
9. Final result: A more efficient system that saves resources and money while providing better functionality.
10. Utilize View X for state management, Yelp data, Firebase database, authentication with GoTrue, and user roles.
11. View X store handles authentication, login, and user data.
12. Login component uses V-model to bind input values to data properties.
13. Authentication flow: Attempts login, checks for first-time users, and redirects to dashboard.
14. User roles allow assigning different roles (e.g., editor, visitor) to users in the system.
15. Benefit from serverless architecture for automatic scaling.


## Reaching Beyond Traditional Boundaries with Clojure • Phil Hofmann • GOTO 2018

URL: [https://www.youtube.com/watch?v=2aIWMYcC4Qc](https://www.youtube.com/watch?v=2aIWMYcC4Qc)

 1. Speaker loves programming and believes it's a creative discipline with no limits but one's mind.
2. Philosophy and computer science share similarities, as Ludwig Wittgenstein discussed boundaries/limits in his work.
3. Programming languages limit problem-solving due to different paradigms.
4. Audience participates via mobile devices during the talk; majority loves programming, knows multiple languages, and has a favorite language.
5. Programming languages create different ways of thinking about problem solving.
6. 74% use Android, some iOS; speaker assumes most haven't seen Lisp before.
7. Lisp has unique data structures and syntax.
8. Closure code can be used for various applications like lecture capture tools.
9. Sharing code between platforms is possible with Closure.
10. Closure has immutable data structures, but atomic references help manage state.
11. Introduced a lecture capture application idea using the Closure language.
12. Explained the importance of sharing code between platforms and how it can be achieved with Closure.
13. Discussed immutable data structures in Closure and their benefits for concurrent problems.
14. Demonstrated hot reloading and state management in a real-world example using Closure.
15. Encouraged learning various programming languages, paradigms, and saving orangutans.


## Persuasive Design • Anders Toxboe • GOTO 2018

URL: [https://www.youtube.com/watch?v=1OA--3GoWso](https://www.youtube.com/watch?v=1OA--3GoWso)

 1. Persuasive design can enhance user experience and engagement by focusing on the relationship aspect of a product, with stages like seduction, first use, and ongoing engagement.
2. Use psychology to increase motivation through techniques such as scarcity (Groupon), social proof (reviews, testimonials), and anchoring (setting expectations).
3. Reduce cognitive load for better usability by chunking information into smaller bits and improving processing fluency with clear visuals and simple language.
4. Utilize persuasive design principles like intentional gaps, tunneling, anchoring, and social proof to guide decisions and increase conversion rates.
5. Consider the endowment effect to encourage users to continue after investing time or effort.
6. Understand the importance of social proof and how it influences user behavior.
7. Persuasive design can be used to encourage users to take action, but sometimes adding friction can also be beneficial.
8. Combine business goals with user goals to create a valuable service that aligns with both parties' interests.
9. Use primary and secondary goals to solve chicken-and-egg problems in collecting data for personalized services.
10. Incorporate pattern recognition, feedback loops, and showing users what to do to reinforce desired behavior.
11. Engage users through gamification and motivation by providing achievable goals, feedback, and intrinsic motivation.
12. Avoid tangent motivations; focus on making the process itself enjoyable.
13. Use variable rewards for unpredictability and increased engagement.
14. Extrinsic motivation can be seen in scoreboards and achievements.
15. High scores may not be effective with a large user base; consider alternatives.
16. Persuasive design should focus on facilitating intrinsic motivation for long-term engagement.
17. Constraining experiences (tunneling) can limit unwanted behaviors.
18. Use persuasive design responsibly to create a better world.


## Why I Was Wrong About TypeScript • TJ VanToll • GOTO 2018

URL: [https://www.youtube.com/watch?v=AQOEZVG2WY0](https://www.youtube.com/watch?v=AQOEZVG2WY0)

 1. Typescript was released in 2012 as a tool for compiling code into JavaScript, differentiating itself from other compile-to-JavaScript tools like CoffeeScript and Dart.
2. Both CoffeeScript and Dart faced challenges in gaining mainstream acceptance within the JavaScript community.
3. TypeScript has seen more success due to its focus on improving the JavaScript language rather than replacing it.
4. NativeScript uses TypeScript for its stack, initially causing concerns but leading to a successful partnership between the two projects.
5. Marketing, partnerships with Google and Microsoft, Visual Studio Code's accessibility, positive feedback from notable companies, and engineering aspects of developer relations have contributed to TypeScript's growth.
6. TypeScript's commitment to the ECMAScript standard, familiarity for JavaScript developers, opt-in typing system, and tooling support in editors like Visual Studio Code make it a valuable tool.
7. TypeScript is popular among frameworks like Angular, React, and NativeScript, offering libraries with inline documentation and suggestions.
8. Flow is another static type checker that operates directly on JavaScript files but has fewer features than TypeScript.
9. Benefits of using TypeScript include improved productivity for large teams, better code understanding, easier collaboration with non-JavaScript developers, and appeal to non-JavaScript developers due to its features from other programming languages like C# and Java.


## A Cartoon Quest: New Adventures for WebAssembly • Lin Clark • GOTO 2018

URL: [https://www.youtube.com/watch?v=rZB9Er8aq4s](https://www.youtube.com/watch?v=rZB9Er8aq4s)

 1. WebAssembly (Wasm) is a technology that enables running programming languages other than JavaScript on the web, initially focusing on C and C++ code.
2. To improve performance, Wasm uses an assembly language designed for conceptual machines, allowing quick compilation over the web.
3. WebAssembly supports memory management through typed arrays and aims to run heavier applications like Photoshop and AutoCAD in browsers.
4. Future features include multi-threading support, SIMD (Single Instruction Multiple Data) for parallel processing, and more efficient compilation techniques.
5. WebAssembly needs support for multi-threading, SIMD, 64-bit addressing, streaming compilation, and HTTP caching to improve performance.
6. Small web assembly modules are being used in places where heavy processing is needed, with fast calls between JavaScript and Wasm essential for integration.
7. Converting complex values like objects to numbers for passing data between JavaScript and Wasm can be slow and complicated.
8. WebAssembly focuses on small modules for specific tasks, with proposals like reference types and host bindings improving integration with existing systems.
9. Integration with browsers' built-in ES module support is crucial for seamless use.
10. Tools like WASM Bind Gen automate glue code creation for different languages.
11. Backwards compatibility is vital for older browsers that don't understand Wasm, with tools like wasm-to-js helping.
12. WebAssembly needs to support high-level language features and integrate with JavaScript GC for efficient use in frameworks.
13. The future of web development includes rewriting parts of JavaScript frameworks using Wasm and compiling statically typed languages to it.
14. Outside the browser, web assembly can be used for portability and security models.
15. WebAssembly combines portability and security of the web, improving performance by allowing native modules to run at nearly native speeds without needing compilation for specific devices.
16. Node can benefit from WebAssembly by providing full portability with a POSIX-like API for accessing system resources.
17. Package name maps proposal will help in mapping module names to paths for loading modules across different platforms.
18. Other use cases like CDNs, edge computing, blockchain, IoT, and more can benefit from WebAssembly's performance and security features.
19. A common runtime would speed up development for these use cases.
20. WebAssembly is still evolving to unlock new opportunities.


## Zen and the Art of Convincing Your Company to Use Rust • Ashley Williams • GOTO 2018

URL: [https://www.youtube.com/watch?v=Pn-1so-Ibsg](https://www.youtube.com/watch?v=Pn-1so-Ibsg)

 - Mozilla contractor and Rust developer, Ashley Williams, shared her experience of convincing NPM to use Rust.
- NPM is the world's largest package registry with over 1 million packages.
- Rust is a systems programming language designed for speed, safety, and thread safety.
- The goal was to provide insights on how to convince companies to adopt Rust.
- Ashley discussed challenges faced during the process and shared tips for success:
  1. Don't completely rewrite your software in Rust.
  2. Introduce new technologies through microservices architecture.
  3. Show up with code to demonstrate the language's capabilities.
  4. Avoid bashing other languages; focus on positives of the chosen technology.
  5. Be a systems developer, not just a web developer.
  6. Focus on safety and productivity rather than speed.
- Rust is a programming language that empowers developers to be systems developers.
- Embrace memory safety guarantees and small memory footprint.
- Compilers are cool; they can make trade-offs irrelevant.
- Zen and the art of motorcycle maintenance: complex systems evolve from simple ones, complete rewrites rarely work.
- Introduce new technology with inclusivity and focus on support elements.
  1. Create documentation for different levels of expertise.
  2. Invest in tooling, such as cargo and crates.io.
  3. Use community channels to share interesting developments.
  4. Emphasize the importance of welcoming beginners.
- Rust has a strong focus on documentation and community support.
  1. It offers tools like cargo, rustfmt, Clippy for linting, and IRC channels for beginners.
  2. Rust has been the most loved programming language in Stack Overflow surveys for three years.
- Be prepared for things to change as Rust is still evolving.
- Writing efficient code in Rust requires understanding memory management and avoiding naive approaches.
- Node's log parsing was slow, so a team tried using Rust.
  1. Rust's default safety features made it slower than expected initially but faster in the end.
  2. Andre Arco used Rust for log parsing and achieved 50k records per second, fitting in free AWS Lambda tier.
- Rust compiler has great error messages and aims to make writing correct code easy.
- The language encourages making wrong things hard or impossible to prevent errors.
- Rust is good at processing files and transforms, useful in various scenarios.
- Server performance affects team dynamics.
  1. Focus on solving real problems, not just cool ones.
  2. Rust is useful for processing files and memory optimization.
- Learning curves can be a blessing in disguise.
- Apply multiple tips simultaneously to enjoy the pleasure of contradictions.
- Gumption (spirited initiative) is essential alongside understanding context and other people's experiences.
- Consider using WebAssembly for faster, more reliable client-side components with Rust.


## Make Web Apps Fun to Build and Easy to Refactor with Elm • Daniel Bachler • GOTO 2017

URL: [https://www.youtube.com/watch?v=ehtn81p06Ow](https://www.youtube.com/watch?v=ehtn81p06Ow)

 1. Elm is a statically typed, purely functional language for building web apps.
2. It simplifies syntax compared to JavaScript and has strong typing with no runtime errors.
3. Addresses pain points of dynamic languages: refactoring issues and lower code quality.
4. Elm's type system ensures correctness and prevents bugs through exhaustive pattern matching.
5. Union types allow modeling complex data structures and states, ensuring all cases are covered.
6. Polymorphic types provide flexibility in defining tree types, using algebraic data types for modeling various cases.
7. Elm has no null or undefined values; uses Maybe to represent missing values.
8. Everything is immutable, requiring creation of new values instead of modifying existing ones.
9. Loops are replaced by map, fold, and recursion.
10. Pure functions make testing easier due to predictable results.
11. Elm uses unidirectional data flow for easy testing and maintenance.
12. Type annotations help with refactoring and ensure correctness.
13. Elm has a strong community, active development, and nice code formatting.
14. The compiler helps catch errors early and ensures semantic versioning.
15. Ports are used for communication between JavaScript and Elm code.
16. Some limitations include not being able to publish native modules or use Chase and decoders automatically.
17. Learn more about Elm at try.elm-lang.org and join the Elm Slack community.


## Augmented Reality - Challenges & Writing AR Experiences in JavaScript • Philipp Nagele • GOTO 2017

URL: [https://www.youtube.com/watch?v=wVOESt-TpSA](https://www.youtube.com/watch?v=wVOESt-TpSA)

 1. Philipp, CTO of Wikitude, introduces AR and its evolution.
2. The reality continuum includes VR, MR (mixed reality), and AR.
3. Digi Capital's funding growth shows the rise in AR/VR investments.
4. Understanding context is crucial for successful AR experiences.
5. Wikitude has been developing an SDK for creating AR since 2010.
6. Major companies like Facebook, Microsoft, Google, and Apple drive the industry.
7. Gartner Hype Cycle places AR in the "peak of inflated expectations" phase.
8. Early examples include hardware-based systems in fighter planes and helicopters.
9. Program and Go is an example of simple AR using location data.
10. Advanced AR uses image recognition, facial detection, and 3D modeling.
11. Field services maintenance, furniture visualization, remote assistance, and training are popular use cases.
12. All AR systems consist of sensing, computing, visualization, and projection parts.
13. Sensing technology improves with stereo cameras, HDR, depth sensors, and radar.
14. Software focuses on understanding the environment and recognizing shapes or objects.
15. Computing status in 2017: advanced with SLAM and VIO.
16. Visualization challenges include believability, adaptive light rendering, and projection on various devices.
17. AR 1.0 example: analog experience of a Roman city arch.
18. Key takeaways for AR: makes the invisible visible and connects offline with online.
19. Context is crucial in AR experiences, ensuring relevance and proper delivery of information.
20. JavaScript can be used to create AR experiences.
21. HTC Dream (T-Mobile G1) was an iconic device as the first commercial Android phone.
22. Weekly SDK architecture includes hardware layer, camera access, gyroscope, optimizations for various platforms, OpenGL rendering, metal rendering, SLAM engine, image recognition, object recognition, and cloud recognition.
23. The speaker discussed their SDK architecture and how it works with JavaScript API on Android, iOS, and Windows 10.
24. They explained how to create augmented reality experiences using images, videos, 3D models, and web views in JavaScript.
25. A location-based experience was demonstrated by overlaying a video onto an image from a catalog.
26. The speaker encouraged attendees to try the SDK on their own and explore more materials on their website.
27. Uses a target management tool to create digital footprints of reference images and match them in real-time.
28. Example: Augmenting an image from a catalog with a video overlay using the Image Tracker.
29. Available for free trial, more information on website.


## Why Backend for Frontend Is Key for Microservices • Brian Grant & Krishnan Ramanathan • GOTO 2017

URL: [https://www.youtube.com/watch?v=PwgQZ8eCGxA](https://www.youtube.com/watch?v=PwgQZ8eCGxA)

 1. Morningstar is an investment research firm with various client segments.
2. They adopted Back end for front end (BFF) architecture to cater to different user experiences and data needs.
3. BFF layers provide a unified API for multiple products, allowing teams to focus on their specific domain while sharing common infrastructure.
4. BFF helps maintain consistency across platforms and enables the reuse of existing APIs.
5. Domain Driven Design (DDD) principles are applied to ensure data normalization and massaging within the service layer.
6. For mobile apps, a separate user experience with different back-ends was chosen for Android and iOS.
7. Bounded context helps maintain consistent domain modeling within the apps and BFF.
8. Naming issues were addressed by adjusting API names and models in the bounded context.
9. Caching, batch processes, and HTTP cache headers were used to improve performance.
10. The Rest discussion focuses on using HTTP verbs and conventions, but opinions may differ on its implementation.
11. Adopted Richardson Maturity Model for RESTful architecture: Level 1-3, reduce API chattiness with view-specific APIs, parallelism, asynchronous operations, and use Play Framework to handle asynchronous requests.
12. Generalized API handles market data and securities, updated security API supports multiple security IDs for viewing information about multiple securities.
13. BFF service uses Play Framework to handle asynchronous operations, parallelism, and error handling.
14. Anti-corruption layer handles different styles of responses from various data providers.
15. Lessons learned: be cautious when splitting services, consider reuse by other teams, use BFF for buffering change management.
16. Service still exists and may be separated in the future.
17. BFF pattern is used for multiple applications, but reuse by other teams is limited.
18. BFF service helps manage changes across different apps.
19. Stub data is added to help client developers work faster.
20. Balance between general-purpose API and view-specific API achieved.
21. Restful approach not heavily used in the BFF service, but it works well for them.
22. BFF acts as a gateway API for mobile applications.
23. Duplication of stuff in BFF is limited, but consistency benefits client application development.


## JavaScript at Uber • Dustin Whittle • GOTO 2017

URL: [https://www.youtube.com/watch?v=IG9gwgUiqZM](https://www.youtube.com/watch?v=IG9gwgUiqZM)

 1. Uber's growth and scale: Present in 73 countries, 470 cities, with 1.5 million active driver partners.
2. JavaScript evolution in Uber's engineering organization: Uses multiple languages (Go, Java, Node.js, Python) for different purposes.
3. Four ways Uber uses JavaScript across its platform: Backend microservices, frontend web applications, data visualization, and external API for developer platform.
4. Uber's focus on availability and scalability: Moved from PHP to Node.js for web applications due to core strengths (asynchronous I/O, non-blocking single threaded event loop, great module ecosystem).
5. Marketplace platform with 3400+ microservices and 100 services per trip.
6. Microservices advantages: Clear ownership boundaries, product specific velocity, independent team velocity, language/platform independence.
7. Node.js adoption due to language independence and talent availability.
8. Challenges of scaling with Node.js: Increased complexity, discovery, eventual consistency, operational overhead, repeated code.
9. Scaling solutions: Application level sharding (Ring Pop), efficient communication (T Channel), distributed tracing (Jager).
10. Node.js performance considerations: Tight interfaces and static typing for quality code.
11. Observability tools like Jager for visualizing distributed applications.
12. Consistent platform foundation for over 250 web applications.
13. Node.js, npm, Express, React, and Redux used for the web platform.
14. Customized internal NPM registry, scaffolding, authentication, security, metrics logging, internationalization, error handling, and analytics tools.
15. Separating front-end services from back-end services allows better utilization of languages and easier scaling.
16. React for standardized UI design across teams, Style Tron for CSS management.
17. React libraries provide various charts and visualizations.
18. Luma GL simplifies WebGL interaction with 64-bit precision.
19. Open source tools available on GitHub and engineering blog.
20. Uber aims to build an open platform for creating moving experiences using their tools and data.
21. Contributions to the community through GitHub, engineering blog, and deep dives into tools on uber.github.com/uber-node and uber.github.com/uber-web.


## CSS vs. JavaScript, Trust vs. Control • Christian Heilmann • GOTO 2017

URL: [https://www.youtube.com/watch?v=_3VsoqpnTrs](https://www.youtube.com/watch?v=_3VsoqpnTrs)

 1. CSS is a complex language with fault-tolerant nature, leading to misunderstandings among developers.
2. Developers should focus on preventing errors before writing code and ensure layouts work across browsers.
3. CSS prefixes can cause issues; prioritize sensible layouts for different browsers.
4. CSS is essential for web development, focusing on user interface enhancement.
5. Browser support and control are beyond developers' reach, but they should build interfaces that work across all browsers.
6. CSS has evolved with features like calculated values, media queries, generated content, animations, transitions, viewport units, flexbox, grid layouts, custom properties, feature queries, and JavaScript integration.
7. Use these tools wisely to create responsive interfaces without compromising performance or accessibility.


## Introducing Elm to a JavaScript App • Richard Feldman • GOTO 2017

URL: [https://www.youtube.com/watch?v=28aJOb1A34o](https://www.youtube.com/watch?v=28aJOb1A34o)

 1. Elm is a functional programming language that compiles to JavaScript, offering different semantics for increased reliability and predictability.
2. Interoperating with existing JavaScript code can be achieved by embedding Elm in HTML elements or using techniques like Elm Architecture for interactivity.
3. The Virtual Dom, Actions, Effects, and Update function help maintain Elm's guarantees while working with JavaScript.
4. Elm Runtime handles rendering and updating the virtual DOM efficiently.
5. Interoperating with JavaScript: Use commands (Elm to JS) and subscriptions (JS to Elm).
6. Transitioning from JavaScript to Elm: Keep existing JavaScript and embed Elm for specific parts.
7. Incrementally integrate Elm into existing apps, considering runtime overhead.
8. Use Elm for business logic with JavaScript handling DOM.
9. Drop-in components in frameworks like React using libraries like react-elm-components.
10. Communicate between Elm and JavaScript using data to preserve guarantees.
11. Resources: Official Elm guide, 'How to use Elm at Work' blog post, courses, books, trainers.


## Avoiding the Nightmare on Elm Street • Thomas Anagrius • GOTO 2017

URL: [https://www.youtube.com/watch?v=Qhx81eI5FPs](https://www.youtube.com/watch?v=Qhx81eI5FPs)

 1. Thomas discusses the challenges of choosing tech for a project.
2. Elm is a typed functional language used in their log aggregation and monitoring tool.
3. Considerations when choosing tech include performance, scalability, team culture, and maintainability.
4. Every technology has its own set of pains; it's about picking the right kind of pain for your project.
5. Elm's unique syntax and learning curve can be challenging, but it offers benefits like type safety and fast execution.
6. Technology selection involves trade-offs.
7. Elm was chosen for its data transformation capabilities, type language benefits, and company culture fit.
8. Being early adopters led to challenges, but the investment is expected to pay off in the long run.
9. Elm's time-traveling debugger provides powerful insights into application state changes.
10. Elm is a functional programming language with powerful features such as time-traveling debugging and type inference.
11. It's useful for specific use cases, but has a steep learning curve.
12. Other languages like CoffeeScript and Facebook's Flow offer similar concepts.
13. The future of Elm involves considering alternatives and exploring various web platform languages.
14. State management is built into the language, making it easier to work with compared to separate libraries or frameworks.
15. React state transformations can lead to runtime exceptions, but Facebook's Flow helps with type inference.
16. Elm is a language that focuses on good decisions when starting new projects; consider alternatives like TypeScript.
17. State management is built into the language and how it's used in Elm.
18. Elm produces a shadow DOM for efficient updates, making it faster than React (factor 5).
19. Language choice impacts performance and control over assumptions.


## We Want WebAssembly • Ben Smith • GOTO 2017

URL: [https://www.youtube.com/watch?v=P2C9bRtCWOA](https://www.youtube.com/watch?v=P2C9bRtCWOA)

 1. Web Assembly is a low-level executable format for the web, offering performance benefits through hardware optimization and focus on low-level operations.
2. Modules contain functions, memory, globals, tables, and exports, allowing for various functionalities within Web Assembly.
3. TVM compiles Java bytecode to JavaScript and Web Assembly, supporting languages like Java, Scala, and Kotlin. TurboScript is a new language that can compile to Web Assembly for browser use.
4. Future improvements include support for more languages (e.g., Lisp, OCaml), exception handling, and Cindy optimizations.
5. WebAssembly will enable faster execution of languages like TypeScript and better integration with existing web technologies like JavaScript.
6. Threads and Atomics are being considered for future updates to improve multitasking capabilities.
7. Collaboration between browser vendors ensures compatibility across platforms, while exception handling and garbage collection can be supported in WebAssembly but not as efficiently as native languages.
8. In the future, developers may use WebAssembly libraries or write code directly in new languages for faster performance. Potential uses include client-side face recognition and support for new programming languages.
9. The goal is to make WebAssembly seamless and unnoticeable, improving overall performance.


## Resilience • Jeremy Keith • GOTO 2016

URL: [https://www.youtube.com/watch?v=t0dUvs3jQnw](https://www.youtube.com/watch?v=t0dUvs3jQnw)

 - Internet creation myth: Paul Baran, Donald Davies, and Vint Cerf developed TCP/IP for a decentralized network.
- World Wide Web project by Tim Berners-Lee at CERN used HTTP, URLs, and HTML to create an accessible platform.
- Simplicity is key in adoption: HTTP isn't the best protocol but it's simple enough for people to use.
- The web's success lies in its openness and lack of central control.
- Tim Berners-Lee's World Wide Web proposal was simple and powerful, leading to adoption.
- HTML grew from 21 elements to 121 over time while maintaining compatibility with older browsers.
- The canvas element allowed for fallback content in older browsers.
- The image element (IMG) was introduced without a closing tag, resulting in the alt attribute for alternative text.
- Responsive web design highlighted issues with handling text and images on the web.
- Introduction of source attribute for responsive images.
- CSS's fault tolerance and simplicity.
- Robustness principle (John Pastel's law) applied to web design.
- Browsers need to be liberal in accepting HTML/CSS due to user switching options.
- John Pastel's law (robustness principle) is about being tolerant of errors and conservative in what you send.
- Declarative languages like HTML and CSS can handle errors better due to their loose error handling.
- Imperative languages, such as JavaScript, require stricter error handling models.
- XHTML 2 was rejected because it had a draconian error handling model that would break the web experience.
- Murphy's Law applies to the web and can cause unexpected issues with client-side JavaScript.
- The auto industry thoroughly tests their cars for safety, similar to how we should test our web applications.
- Progressive enhancement approach leads to better experiences for all users.
- Embrace chaos of web and user needs over developer convenience.
- Focus on core functionality and make it available with the simplest technology.
- Enhance the experience by adding more features, ensuring compatibility across devices and browsers.
- The three steps: 1) Core functionality for everyone, 2) Simple tech, 3) Enhanced features.
- Embrace chaos of web and user needs over developer convenience.
- Progressive enhancement is a way of thinking, not just a feature.
- Focus on core functionality and compatibility.
- Start with accessibility and responsiveness in mind.
- Draw the line between core functionality and enhancements based on user needs.
- Easier to design this way from the start than retrofitting later.


## The Frontend Taboo: a Story of Full Stack Microservices • Luis Mineiro & Moritz Grauel • GOTO 2016

URL: [https://www.youtube.com/watch?v=vCzTK4XPfX8](https://www.youtube.com/watch?v=vCzTK4XPfX8)

Error


## You Can Use CSS For That! • Rachel Andrew • GOTO 2016

URL: [https://www.youtube.com/watch?v=TNhR6ol9mBc](https://www.youtube.com/watch?v=TNhR6ol9mBc)

 - CSS Layout: Flexbox and Grid
- Box Alignment: A new specification for alignment in layouts, not limited to block layouts.
- CSS Grid Layout: Designed as a fifth purpose layout method, for two-dimensional layouts.
- Min Max: Allows setting minimum and maximum values for track sizes in grid layouts.
- Practical use case: Using grid layout to handle varying content lengths without breaking the design.
- Grid layout allows flexible container design with varying column tracks.
- Min and max values can be used to set minimum and maximum sizes for elements, ensuring they don't break the layout.
- Auto placement algorithm in grid layout helps arrange items efficiently.
- Grid auto flow property can backfill gaps in the grid for a tightly packed display.
- Accessibility should be considered when using grid layout as it may affect logical order of content.
- Grid layout is currently being developed behind browser flags, with support expected to ship in major browsers soon.
- Display contents allows elements to be treated as grid or flex items without affecting their position in the DOM.
- CSS shapes enable text flow around curved lines or other non-rectangular objects.
- Clip paths can be used to clip away content around images, providing a nice enhancement for websites.
- Modernizer is a tool that detects support for CSS features within browsers without using JavaScript.
- Feature queries allow checking browser support before using new features.
- Initial letter property creates proper drop caps effect.
- Test for initial letter support with feature queries.
- Writing modes help control content direction, useful for mixed languages and creative text effects.
- Custom properties (CSS variables): Define values and use them in your stylesheets.
- Calc function: Perform basic math operations with length units in CSS.
- Sticky positioning: A new value of the position property that makes elements stick when they reach the top of the viewport, commonly used for navigation.
- Scroll snapping helps pages behave more like apps by automatically moving to the next section when scrolled past a specific point.
- Encourage browser vendors to adopt new features by raising bugs and discussing use cases.
- Share thoughts on CSS working group patterns and specs.
- Participate in discussions about early stage CSS specifications on GitHub.
- Grid layout is expected to be in browsers early next year but may have performance issues. Start learning now for better understanding when fully supported.
- Use feature queries to detect support of grid and enhance layouts instead of polyfilling.
- Discussions on how user agents should handle lazy loading content are not currently addressed in the specification.


## JavaScript, the Cloud & the Rise of the New Virtual Machine • Scott Hanselman • GOTO 2016

URL: [https://www.youtube.com/watch?v=7LZ0Lznq4Aw](https://www.youtube.com/watch?v=7LZ0Lznq4Aw)

 - The cloud is more than just a remote computer, offering flexibility and scalability through virtualization.
- Virtualization allows machines to be moved and run in different locations, with 30% of Azure running on Linux as an example.
- Programmatic ability to create virtual machines is crucial for understanding the underlying technology.
- Cloud computing encapsulates best practices for scaling web systems, making it easier to use and more efficient.
- Learning about virtual machines helps understand cloud computing's underlying technology.
- Language choice in development doesn't matter; focus on what makes the developer happy.
- High-level abstraction in cloud computing allows better decision-making and problem solving.
- Renting resources from a cloud provider means they handle failures and issues, reducing workload.
- A dashboard should show the big picture of company operations, not just monitoring.
- Yak shaving refers to extra steps before accomplishing tasks; cloud computing allows higher-level problem solving.
- Functions as a service (FaaS) enables scaling based on input/output.
- Tim Berners-Lee's vision for the internet was as a hypermedia book, not an application platform.
- Inventors of technologies like PDF and YouTube made the web more appealing.
- Toyota uses hybrid systems with outdated software like Windows XP and Firefox.
- JavaScript is versatile, allowing developers to create impressive projects and complete operating systems.
- Atwood's Law states that any application written in JavaScript will eventually be rewritten in JavaScript.
- HTML5 and the open web are pushing technology forward as a viable alternative to native apps.
- Web design has evolved from simple HTML tables to complex frameworks.
- jQuery is popular, but vanilla JS can create custom frameworks.
- The web is powerful with integrated virtual machines in browsers; cloud computing helps offload tasks for better efficiency.


## Building an App Using JS/TypeScript, Node, Electron & 100 OSS Components • Erich Gamma • GOTO 2016

URL: [https://www.youtube.com/watch?v=uLrnQtAq5Ec](https://www.youtube.com/watch?v=uLrnQtAq5Ec)

 1. Transition from IBM to Microsoft
2. Learning JavaScript and web technologies during a four-month break
3. Building tools for online development with Microsoft
4. Developing Visual Studio Code editor
5. Embracing open source at Microsoft
6. Pivoting from browser-based IDE to desktop ID using the same technology
7. Recognition of Microsoft's transformation through open source announcements - Microsoft transitioned from focusing on Visual Studio to enabling developers to use their preferred tools and platforms.
8. The shift included moving away from a compiler-based approach, embracing open source, and developing a cross-platform desktop IDE with a focus on the inner loop (development process).
9. The new editor aims for lightweight, keyboard-centered functionality while maintaining intelligence and debugging capabilities.
10. OmniSharp is a project that enables C# development in any editor by moving the brains of the language to the editor itself - Demonstration of C# development with OmniSharp, an open source project that enables cross-platform usage.
11. Visual Studio uses electron, a web technology for desktop applications.
12. Typescript was adopted to improve the codebase and provide better tooling support.
13. Typescript offers optional static types, flexible type system, generics, structural typing, interfaces, and powerful type inference for improved safety and documentation - Adoption of TypeScript for better code maintenance and flexibility.
14. Moving from Eclipse's plugin model to a separate extension host for robustness and performance.
15. Using Node and Typescript for extension development, with a focus on deep language integration.
16. Providing an API that enables rich language support for various languages in the editor - Separate extension host for better performance and robustness.
17. Node.js based, allowing reuse of modules in extensions.
18. Fluid API with deep language integration support.
19. Extension ecosystem with marketplace for easy discovery.
20. Lazy activation feature for efficient resource usage.
21. Demonstration of creating an extension with hover provider - Richer code experience through typed TypeScript and JavaScript.
22. Language servers for different programming languages.
23. Open source approach with daily updates and feedback channels.
24. Microsoft's transformation with Visual Studio Code as an example.
25. Encouraging users to create extensions and publish them.


## Visual Studio Code: Shipping One of the Largest Microsoft JavaScript Apps • Alex Dima • GOTO 2016

URL: [https://www.youtube.com/watch?v=mTKMefhTjh8](https://www.youtube.com/watch?v=mTKMefhTjh8)

 1. Visual Studio Code is a web app built using JavaScript and Node.js, with the Monaco Editor as a separate library.
2. The team behind VS Code started in 2011, focusing on JavaScript development tools for browsers.
3. They adopted TypeScript early on, which provides optional syntactical constructs like type annotations and interfaces to enhance productivity.
4. TypeScript compiles down to JavaScript, offering runtime benefits without additional costs. Rich tooling at compile time helps catch errors before runtime, improving code quality.
5. TypeScript is a superset of JavaScript that adds type annotations and other features, helping catch errors early, improve code readability, and enable better refactoring. It can compile to ECMAScript 5 or lower versions while still using newer syntax.
6. Destructuring and async/await are supported in TypeScript for easier coding.
7. TypeScript's compiler generates a tsconfig.json file that contains instructions for the compiler, such as targeting specific ECMAScript versions.
8. CommonJS and AMD (Asynchronous Module Definition) are two module systems for JavaScript. TypeScript supports compiling to either CommonJS or AMD formats.
9. Lazy code loading is an advantage of AMD, allowing only necessary dependencies to be loaded when needed. Bundling and minifying code can improve startup time by reducing the number of HTTP requests. Minification helps V8's performance by optimizing function bodies under 600 characters.
10. TypeScript can help with better data structures and memory leaks detection. Compile TypeScript to JavaScript for different teams or projects.
11. View models can improve readability and performance by splitting long strings into multiple lines.
12. Electron is a framework that combines HTML, Node.js, and Chromium to create desktop applications using JavaScript. It uses main and renderer processes for communication with the operating system and UI elements, respectively.
13. Visual Studio Code uses multiple processes for different tasks like checking updates, managing extensions, and running on-demand processes. Gulp watch is used to compile TypeScript code incrementally during development.
14. A demo was shown where a small change in CSS made the editor background appear like beer, highlighting Electron's flexibility. Performance tests and virtual scrolling technique were discussed. Issues with minified code, specifically jQuery, were mentioned. Chrome's enabled pane flashing tool for profiling was utilized. Translate3d was used to improve performance.


## Beyond Flux - Scalable Frontend Architectures built upon Publish/Subscribe • M. Kurze • GOTO 2016

URL: [https://www.youtube.com/watch?v=82rrMIf48Zk](https://www.youtube.com/watch?v=82rrMIf48Zk)

 1. Increasing complexity in web applications necessitates better tools and architecture.
2. Three main challenges: managing complexity, ensuring reactivity, and scaling across teams.
3. Unidirectional data flow (Flux) is a solution to handle state, views, and actions.
4. Multiple Flux implementations exist, including Redux which is popular nowadays.
5. A simple web shop example demonstrates how Flux works with multiple stores managing different aspects of the application.
6. Advantages of Flux over MVC: strict separation of state, single storage for state, good testability, simplifies server-side rendering.
7. Disadvantages: harder to manage complex actions, testing difficulties due to dependencies between stores.
8. Compare advantages and disadvantages of classical MVC approaches vs Flux architecture.
9. Flux has better state management, testability, and server-side rendering.
10. Redux eliminates mutable state problems and offers functional composition, snapshot replay, and efficient rendering.
11. Immutable data types can help prevent accidental modifications but may have a steep learning curve.
12. Container components in Redux allow decoupling of components for scalability.
13. Introduced immutable data types and their benefits.
14. Discussed challenges of mutable JS and functional programming paradigms.
15. Explained container components in Redux and their limitations.
16. Presented publish-subscribe architecture as an alternative solution.
17. Described event bus, view, and activity components in this new approach.
18. Demonstrated how it allows decoupling and unidirectional data flow.
19. Highlighted the benefits of this pattern for scalability and maintainability.
20. Introduced a framework called LuxarJS which provides event bus functionality and component configuration.
21. Advantages include decoupling of components, easier testing, reusability across applications, and flexibility in choosing development approaches.
22. Discussed the similarities between LuxarJS and Flux/Redux in terms of unidirectional data flow and handling complexity, reactivity, and scalability.


## Busy Developer's Guide to MeteorJS • Ted Neward • GOTO 2016

URL: [https://www.youtube.com/watch?v=uMSY-vWB23w](https://www.youtube.com/watch?v=uMSY-vWB23w)

 - Meteor is a full-stack JavaScript framework, embracing the language in its database, server, and client.
- It uses either Angular, React, or Blaze for frontend development.
- Data on the wire concept: only data travels between client and server.
- Meteor supports various cloud platforms and NPM ecosystems.
- Full stack reactivity: live page updates, data synchronization, latency compensation, hot code pushes.
- Security is taken seriously with insecure package by default, allowing customization of what gets shipped to the client.
- It's a classic MEAN stack (MongoDB, Express, Angular/React, Node.js).
- Meteor has a specific directory structure for client and server code.
- NPM is used to manage dependencies.
- ECMAScript 6 features are used in Meteor applications.
- Meteor offers a command line tool, build tool, and deployment options.
- Transpilers like Babel and TypeScript can be used for non-Meteor projects that need ES6 support.
- Meteor uses prototype inheritance and ECMAScript import syntax.
- It creates file structure with directories for client, server, imports, public, and private assets.
- Components in meteor are more domain-related than reusable across applications.
- Tasks are managed through templates with events to handle form submissions and updates.
- Meteor uses mini-mongo for client-side database and has an ecosystem of packages for user management.
- The platform is opinionated about the type of databases it supports, preferring JSON style ones. Relational databases may need adaptation.


## The Return of Stream I/O • Andre 'Staltz' Medeiros • GOTO 2016

URL: [https://www.youtube.com/watch?v=Tkjg179M-Nc](https://www.youtube.com/watch?v=Tkjg179M-Nc)

 1. Andre's talk focuses on the return of Stream IO and its similarity to an old concept in Haskell, as well as his journey with reactive programming through Future Eyes.
2. Psycho JS is a small library for frontend frameworks that uses message passing, input/output logic, and streams for asynchronous programming.
3. Stream IO separates logic from effects by treating them as data, similar to monadic I/O in Haskell. It uses generators for pausing and resuming execution.
4. Haskell's original stream IO was an April Fool's joke, making it unsuitable for transformational programs.
5. The history of computer programming has seen a shift from transformational systems (90s) to reactive systems. Haskell moved from stream IO to monadic IO in the late 90s.
6. Psycho JS is a JavaScript framework with message passing, input/output logic, and streams for asynchronous programming. Cycle.js has asynchronous message passing, suitable for user interfaces or reactive systems but not question-and-answer interactions. Elm Architecture handles complex requests and responses using tasks.
7. Message passing can be combined with monadic IO in Elm. Flux and Redux have unidirectional data flow but lack a purely functional approach.
8. Languages like Elm, Closure, Dart, etc., focus on asynchronous programming and message passing. Cycle JS is event-driven and message-passing concurrency.
9. Enforcing developers to avoid creating their own effects can be done with tools like ESLint plugins or by writing a language optimized for the framework.
10. Bind and flatMap are implemented in hacky JavaScript monadic IO, which may not be ideal for reactive UI. Haskell has functional reactive programming libraries.
11. Consider using TypeScript with Angular to benefit from its type checking and self-documenting code. Elm is a purely functional language with zero runtime errors.


## Elm-Friendly Functional Programming For The Web • Luke Westby • GOTO 2016

URL: [https://www.youtube.com/watch?v=tN5UmM2yZPY](https://www.youtube.com/watch?v=tN5UmM2yZPY)

 1. Elm is a functional programming language designed for the web, focusing on data and functions.
2. Setting up an Elm project involves installation, package management, and creating index.html.
3. Data in Elm has types and shapes, with relationships created using functions.
4. Immutable updates and state management ensure reliable apps with delightful user experiences.
5. Elm's type system catches errors during compilation, while records are used for structured data.
6. Type aliases help refactor code and prevent duplication issues.
7. Custom data types ensure safe code and prevent runtime errors.
8. Pattern matching guarantees robust programs by covering all cases.
9. Elm's syntax keeps developers safe from runtime errors, allowing them to build web apps with confidence.
10. Import HTML and create a basic Elm app with static HTML.
11. Understand the MVU architecture (Model, View, Update) for building Elm applications.
12. Create a model, define update functions, and refactor code into view function with click events.
13. Compile the program using Reactor for real-time debugging.
14. Introduced custom Union types for messages in an application.
15. Created an interactive app with HTML, Elm, and no runtime errors.
16. Share resources to learn more about Elm and join its community.
17. Discuss the benefits of functional languages for web development.


## Ionic: Mobile App Development with a Superpowered Platform • Matt Kremer • GOTO 2016

URL: [https://www.youtube.com/watch?v=P7NPfjqeXPY](https://www.youtube.com/watch?v=P7NPfjqeXPY)

 - 20+ years of web evolution: from simple websites to dynamic and powerful apps
- Ionic in 2013: a platform for building hybrid mobile apps using HTML, CSS, JavaScript
- Hybrid apps use web technologies with native API access, providing a single code base for multiple platforms
- Web technology advancements have improved performance, making web apps more competitive with native apps
- Ionic provides a single code base for iOS, Android, Windows, etc., making it easier to build apps
- Ionic uses Angular 1 or 2, allowing customization through SAS (CSS preprocessor)
- The stack includes native SDKs, Cordova/PhoneGap, Angular, and Ionic
- Anak two is modern, modular, object-oriented JavaScript with typescript support
- Ionic offers various features to simplify app development, including UI components, navigation, and tools like Ionic Creator
- Ionic is a large ecosystem with CSS, JavaScript, and various components
- Ionic UI components are well-documented for easy use
- Collection repeat optimizes DOM performance by loading only visible items
- Angular 2 (ionic 2) has improved animations, navigation, and material design support
- Platform continuity allows the same code base to work on iOS, Android, and Windows devices with automatic platform detection
- Ionic 2 conference video transcript: Google "ionic 2 conference" for more info
- GitHub has app source code, regular Angular 2 with TypeScript
- Slider component, material design animations, platform continuity, 700+ free icons
- Ionic CLI makes development easy
- Ionic Lab GUI tool for serving and previewing apps
- Ionic View for live app previews on phones
- ngCordova and ionic native for using Cordova plugins with Angular
- Ionic Marketplace has starters, plugins, themes (free/paid)
- Ionic Creator helps non-coders design apps visually
- Ionic Showcase: Proof of real apps built with Ionic
- App Camp: Learn Angular alongside Ionic
- Jobs Board: Find Ionic jobs
- Platform: Small plans, authentication, push notifications, Ionic Build (builds iOS/Android apps), Deploy (updates app assets)
- Future improvements: Revamping Ionic Lab and adding more features to the platform
- Ionic is a platform that allows developers to easily integrate with social media platforms like Twitter, Facebook, and LinkedIn
- It offers custom authentication, push notifications, and enterprise-ready features
- Ionic Build enables packaging of apps for iOS and Android through email deployment
- Deploy service updates apps without going through the App Store process
- Ionic has a large community with active meetups and a forum
- The platform works closely with Angular core team to ensure compatibility


## The Post-MVC Age • Maarten Hus • GOTO 2016

URL: [https://www.youtube.com/watch?v=QQxNr6t1HEc](https://www.youtube.com/watch?v=QQxNr6t1HEc)

 1. Components are the new way to build applications, offering characteristics such as isolation, declarative nature, composability, and clear input/output semantics.
2. Challenges in component-based apps include state management and communication between components.
3. Redux is a popular solution for these challenges, focusing on unidirectional data flow through its core concept of the store.
4. Benefits of using Redux include simplifying universal JavaScript, providing good developer experience with tools like time travel debugging, and handling complex states.
5. Reactive programming, specifically RxJS, is another powerful tool for asynchronous event handling and supercharging components.
6. Learning curves: Redux has a small learning curve, while RxJS has a steep one.
7. Performance considerations: Redux may degrade with large state but can be mitigated by pagination or storing only necessary data.
8. Memory leaks are not common in Redux due to its single store per application.
9. Component architecture differs from Model-View-Controller, as components combine view and controller into one entity. Angular 2 embraces component architecture for easier migration.


## Adventures in Elm • Jessica Kerr • GOTO 2016

URL: [https://www.youtube.com/watch?v=cgXhMc8M4X4](https://www.youtube.com/watch?v=cgXhMc8M4X4)

 - Exploring Elm: A functional programming language focused on UI development
- Data-driven architecture with minimal updates for UI changes
- Smaller ecosystem compared to JavaScript, but more people-friendly
- Compile errors prevent undefined issues
- Elm is accessible to various developers and has live coding demonstrations
- Features include curried functions, type aliases, records, union types, pattern matching, simplicity, readability, testability
- Elm package manager ensures API stability and documentation
- Direct translation between data structure and HTML for code generation
- Refactoring and compiler improvements for better user experience
- Main function returns a program with type parameter for arguments from JavaScript
- Focus on modularity, code organization, and separation of business logic from view functions
- Types and immutability ensure safe code changes and encapsulation
- Elm community is enjoyable with upcoming events
- Code for presentation available on GitHub


## JavaScript Performance Through the Spyglass • Vyacheslav Egorov • GOTO 2016

URL: [https://www.youtube.com/watch?v=r76ZjdzFExg](https://www.youtube.com/watch?v=r76ZjdzFExg)

 1. Understanding JavaScript performance requires knowledge of VM internals.
2. V8's let binding for loop optimization can be inefficient, leading to nested loops.
3. Profiling helps identify issues and optimize code; tools like Perf on Linux provide CPU performance counters.
4. In the example, allocating an array outside of a function improved performance.
5. V8's fast new closure allocation doesn't support arrays inside closures.
6. Microbenchmarks can lead to misleading results; inlining functions may not always improve performance.
7. Doubt everything, including microbenchmark results and use tools like Perf for accurate analysis.
8. Repeat operations multiple times and divide by iterations for more accurate cost measurements.
9. Microbenchmarks can be misleading due to JIT compilers optimizing code; constant propagation, loop invariant code motion, and dead code elimination are common optimizations.
10. Avoid using microbenchmarks; focus on fixing bugs or other useful tasks instead.
11. Verify benchmark results for accuracy; optimizers can make microbenchmarks irrelevant.
12. Avoid loop invariants and dead code; compilers may optimize differently, leading to unexpected results.
13. Be aware of compiler bugs and their impact on performance; confirmation bias can lead to misleading conclusions about performance.
14. Intermediate representation used by the compiler; getters can be inlined into loops for better performance.
15. Older V8 had issues with properties on prototypes, but newer versions handle them better.
16. Optimization bugs exist in compilers; boxing of numbers in v8 can cause performance issues.
17. Object-oriented programming is optimized for v8; other VMs have similar issues that can be analyzed with disassembly.
18. Object-oriented programming is faster in V8; function call vs method call performance comparison: function slower due to unoptimized version, now both perform the same after optimization.
19. Dart VM code optimization example: Replacing non-executed method calls and property accesses improved performance.
20. Inlining decisions in V8 based on source code size; don't assume language features are slow, report bugs to improve them.


## Emulating a 6502 system in JavaScript • Matt Godbolt • GOTO 2016

URL: [https://www.youtube.com/watch?v=7WuRq-Wmw5o](https://www.youtube.com/watch?v=7WuRq-Wmw5o)

 - 6502 is an influential 8-bit computer from 1975 with 3,510 transistors.
- It was used in popular computers like Apple II, Atari 800, BBC Micro, Commodore Pet, and Nintendo Entertainment System.
- The BBC Micro was part of the UK's Computer Literacy Program.
- The 6502 processor inspired the ARM chip found in modern smartphones.
- Learning to program involved typing code from magazines and debugging errors.
- 6502 processor features: 8-bit, three registers (accumulator, X&Y), 256 bytes of stack, assembly instructions, memory addressing, efficiency in memory usage, advanced features, emulator development.
- Emulating a 6502 system requires understanding hardware manuals and configuring various components.
- Reverse engineering the 6502 netlist to create virtual processors and simulate behavior.
- Protection systems in games used encryption, hardware timers, and interrupts.
- A 6502 emulator was created to crack a game with complex protection system.
- JavaScript performance tips: avoid switch statements, don't use dynamic dispatch, loop unrolling is useful, use typed arrays for screen, WebGL for multi-threading.
- Collaborate with game creators and utilize resources like Visual 6502, GitHub, websites for further learning.


## Enhanced Front-end Applications in AngularJS 1.3 • Matias Niemela • GOTO 2014

URL: [https://www.youtube.com/watch?v=CTezvNSQPYw](https://www.youtube.com/watch?v=CTezvNSQPYw)

 1. AngularJS is an MVC framework that separates frontend and backend, making testing easier.
2. It uses HTML components for more functionality with less code.
3. SEO support is improving but not perfect yet.
4. Modules and expressions build the application structure.
5. Dynamic templates use data to update the page without reloading.
6. Scope manages application memory, allowing data changes to reflect in the template.
7. Controllers manage specific areas of an application with interactivity.
8. Data binding updates the template when user input changes.
9. Filters format output of data.
10. ngRepeat repeats data and automatically updates the view.
11. Angular's digest cycle updates the page without callbacks.
12. Directives add custom functionality to web pages.
13. Dependency injection enables code reuse and testing.
14. Routing maps URLs to specific pages in an angular application.
15. Unit testing frameworks like Jasmine, Mocha, and Karma test Angular apps.
16. Debugging tools include the console and dollar zero.
17. Protractor tests Angular apps' integration.
18. Angular 1.3 introduces form validation with custom validators and improved error message display.
19. ngModelOptions customizes model behavior, including data binding and animation.
20. Animation support includes CSS animations, JavaScript code triggers, and multiple animations running simultaneously.
21. Animate.css is a third-party library for animations in Angular apps.
22. Reintegration adds accessibility features to Angular applications.
23. Polymer and Angular may have compatibility issues due to their development stages.
24. Angular 1.3 improves performance, browser incompatibilities, and introduces new features like bind once and digesting specific parts of the application.


## Web Assembly • Nick Bray • GOTO 2015

URL: [https://www.youtube.com/watch?v=NhAPPQqKCi8](https://www.youtube.com/watch?v=NhAPPQqKCi8)

 - Web Assembly is a new technology designed to run native code on the web, addressing issues from previous solutions.
- It offers promising cross-platform development and legacy code porting capabilities.
- JavaScript performance has improved but remains inconsistent due to JIT compilers and garbage collection pauses.
- Porting code to the web is challenging yet offers unique strengths like openness, vendor lock-in avoidance, security, portability, ephemerality, and evergreen apps.
- WebAssembly aims to combine these properties with native performance, addressing past issues.
- It has a binary format for better performance and portability, loading files in browsers and integrating with JavaScript engines.
- Benefits include smaller file sizes, faster start-up times, and easier updates.
- No pointers are used; data types are represented as integers.
- WebAssembly is a portable machine architecture, not a programming language.
- It's smaller than JavaScript, reducing file size by up to 25% before compression. Parsing binary format is 23 times faster than text.
- Integrates with JavaScript for foreign function invocation.
- First version can be translated to JavaScript for browsers without native support.
- No pointers in WebAssembly; data types are represented as integers.
- Early work shows Web Assembly running at 30 frames per second on a patched Chrome browser (compared to 32 frames with JavaScript).
- WebAssembly is a new technology aiming for improved performance and predictability of web applications, simplifying the process of getting high performance.
- Native code can run faster than JavaScript due to differences in floating point math precision.
- Shared memory multi-threading will be added later as it's complicated and requires careful specification. Dynamic linking is another important feature allowing sharing functionality between apps and partial downloads.
- WebAssembly is a new binary format for the web, executing compiled code from various languages, initially focusing on "byte bucket" languages like Python and C/C++. Memory safety and garbage collection are planned for future versions. Browser vendors coordinate efforts through GitHub. Target audience includes game engine developers, web developers, and native developers.
- WebAssembly could potentially be used with high-performance libraries like OpenAL and libvorbis.
- Game engine developers' target audience consists of skilled, dedicated people working on multiple platforms. Web development is easier to learn and use, with JavaScript being popular. Native code has limitations in terms of accessibility and ease of use. Different ecosystems between web and other platforms make it hard to predict their future merging. Web APIs will be different from native ones, requiring compatibility libraries for integration.


## Benchmarking JavaScript • Vyacheslav Egorov • GOTO 2015

URL: [https://www.youtube.com/watch?v=g0ek4vV7nEA](https://www.youtube.com/watch?v=g0ek4vV7nEA)

 1. Complexity in VMs can lead to slow performance for simple code, making it crucial to benchmark carefully.
2. Ensure that each operation in a benchmark performs the same amount of work every time and use real code for accurate results.
3. Browsers optimize code during execution, making predicting performance difficult. Understand different costs involved and how compilers optimize code.
4. Avoid common optimizations like constants, loop invariants, and dead code elimination when writing benchmarks. Verify results to trick certain optimizations.
5. Use real code and production applications for more accurate benchmarks. Write benchmarks that avoid common optimizations.
6. VMs can find bugs in benchmarks or cause them to become nothing; assume reasonable code is reasonably fast, focusing on understanding what happens inside the VM.
7. Older versions of V8 may not support certain optimizations, leading to misleading results. Counter optimization in loops can slow down when counter overflows multiple times. Method invocation vs function call performance: Function calls are slower than method calls due to a lack of optimization.
8. Concatenation trick for faster function calls: Adding concatenations before the benchmark improves performance.
9. Inlining can improve code execution speed by removing unnecessary loops. V8's optimization process is complex, sometimes leading to unexpected results; consult with the VM team for accurate benchmarks and performance analysis.


## The Front End Architecture Revolution • David Nolen • GOTO 2015

URL: [https://www.youtube.com/watch?v=nDNU2pmuJA8](https://www.youtube.com/watch?v=nDNU2pmuJA8)

 1. Embrace simplicity in software architecture for better global optimization.
2. React and Redux are examples of simple technologies that can lead to faster applications.
3. Global optimization is not always at odds with modularity, as seen in garbage collection.
4. Find comparable alternatives if you don't want to adopt a specific technology; focus on its properties rather than the exact tool.
5. Embrace simplicity for global optimization.
6. React, ClojureScript, and transit are recommended technologies with immutability support.
7. Backbone, Ember, and Angular suffer from mutable data structure limitations.
8. React's design allows for immutable data structures.
9. Data dominates programming; choose the right data structures for simplicity.
10. The speaker discusses the importance of data structures in programming.
11. React is praised for supporting immutable data structures, leading to better performance and reasoning.
12. ClojureScript and Immutable.js are mentioned as effective solutions for state management and undo/redo functionality.
13. Typescript, Elm, Dart, Scala, CoffeeScript, and Babel are also highlighted as compelling options in the JavaScript ecosystem.
14. Google Closure is praised for its optimization capabilities and ability to be used on both frontend and backend development.
15. Transit is a data format for moving immutable data from backend to frontend.
16. It supports richer types, extensibility, and fast decoding.
17. Meteor is a radical approach that simplifies app development by combining server and client code.
18. Transit is a powerful tool for sharing data across multiple applications.
19. Meteor's radical approach: React and Relay, which simplify UI programming by letting clients define their required data structure.
20. Netflix and Facebook use similar techniques with Falkor and GraphQL.
21. Recursive data description allows efficient querying and composition of data structures.
22. Pull requests in Atomic database enable efficient data retrieval for specific elements.
23. Radical simplicity is achieved by adopting these approaches, reducing complexity and improving UI programming.
24. Speaker discusses simplifying complex nested queries.
25. Uses React and Relay GraphQL to represent queries directly on UI components.
26. Rest is not going away, but its complexity may be reduced.
27. Immutable data model like Git can help reduce complexity.
28. Older technologies like Lisp have time-tested engineering ideas.


## Conquering Time with Functional Reactive Programming • Sergi Mansilla • GOTO 2014

URL: [https://www.youtube.com/watch?v=gT6il5fJyAs](https://www.youtube.com/watch?v=gT6il5fJyAs)

 1. JavaScript deals with time and asynchronous tasks, leading to complex code.
2. Functional programming focuses on the "what" instead of the "how".
3. State is dangerous in programming, especially when dealing with events.
4. Event limbo refers to challenges faced by events in JavaScript.
5. FRP (Functional Reactive Programming) can help solve these issues by treating time as a first-class citizen and making events first-class citizens.
6. Rx is a platform for reactive programming that helps compose synchronous and event-based programs across various languages.
7. Observables in Rx are like iterators but push data to the observer instead of pulling from collections.
8. The Observer pattern has limitations, while observable patterns can signal completion or errors.
9. Real-world example: Using Rx to filter, throttle, and accept distinct values for a search input.
10. Observables improve performance by executing only when needed.
11. Reactive programming focuses on sequences of events and composing them.
12. Testing becomes easier with schedulers and customizable behavior.
13. RxJS is a popular reactive library used by companies like Netflix, Microsoft, SoundCloud, and GitHub.
14. Model-View-Controller (MVC) can work with RxJS by having the view subscribe to the controller, which observes the model.
15. Subjects are entities that inherit from both observable and observer, allowing them to do both at once.


## Lessons Learned from Building a CSS Minifier • Stoyan Stefanov • GOTO 2014

URL: [https://www.youtube.com/watch?v=SV2f3whvvm0](https://www.youtube.com/watch?v=SV2f3whvvm0)

 - CSS performance issues: Blocks page rendering, requires optimization.
- Common strategies to improve loading time: Inline critical CSS, split into multiple files, use local storage or CDNs.
- Challenges with CSS complexity: Positioning, formatting context, specificity, cascade inheritance.
- Solution: Learn CSS thoroughly and understand its architecture for larger web applications.
- Minification techniques: Regular expressions (regex) or partial parsing. Complex properties like shorthand background declarations require more advanced parsers.
- The speaker discusses CSS refactoring issues and the need for a unifier. They mention using regular expressions, parsers, and abstract syntax trees to improve minification. A new tool called CSS Shrink is introduced.
- Minify CSS code by removing unnecessary characters and optimizing syntax. Consistency is key for better Gzip compression. Remove empty rules, duplicate declarations, and invalid properties. Merge adjacent selectors with the same content. Strip generic font families from CSS. Validate CSS to ensure proper syntax and value usage.
- Avoid manipulating CSS with JavaScript as it can break optimizations. Optimize CSS by removing duplicate keyframes, using shorter names for variables, and converting units. Use browser-specific CSS to reduce page load size. Test CSS transformations with tools like CSS diff and PhantomJS. Explore object-oriented CSS, SMACSS, and CSS for grown-ups/grumpy old men. Continue experimenting with CSS transforms and minification techniques.

No context:
1. Improve CSS performance by optimizing loading time.
2. Address challenges in CSS complexity.
3. Learn CSS thoroughly to handle larger web applications.
4. Use minification techniques for better compression.
5. Remove unnecessary characters, duplicate declarations, and invalid properties.
6. Merge adjacent selectors with the same content.
7. Strip generic font families from CSS.
8. Validate CSS syntax and value usage.
9. Avoid manipulating CSS with JavaScript.
10. Optimize CSS by removing duplicates and converting units.
11. Use browser-specific CSS for reduced page load size.
12. Test transformations using tools like CSS diff and PhantomJS.
13. Explore object-oriented CSS, SMACSS, and CSS for grown-ups/grumpy old men.
14. Continue experimenting with CSS transforms and minification techniques.


